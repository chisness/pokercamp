---
title: "Kuhn Poker (1): Challenge"
sidebar: aipcs24
format:
  html:
    math: true
    css: styles.css
    header-includes: |
      <script src="https://d3js.org/d3.v7.min.js"></script>
---

## UNDER CONSTRUCTION! 

## Kuhn Poker
Kuhn Poker is the most simple version of poker. Here is the setup: 

- 3 card deck: Queen, King, Ace (in ascending order, so Ace is highest)

:::{.callout-tip collapse="true"  appearance="minimal"}
## Alternative Decks 

  - Any deck of 3 ranked cards works

  - This could be numbers like {0, 1, 2} or other cards like {Jack, Queen, King}
:::

- 2 players

- Each player starts with 2 <abbr title="Betting currency -- the goal is to win these">chips</abbr> and <abbr title="An ante is a forced bet">antes</abbr> 1 chip

- Deal 1 card to each player (discard the third)

![](assets/kuhn.png)

- There is one betting round in which players can take these actions: 

  - Up ↑ (putting a chip into the pot) 
  
  - Down ↓ (not putting a chip into the pot) 

:::{.callout-tip collapse="true"  appearance="minimal"}
## Poker Terms for Actions 

  - Up ↑ actions indicate a <abbr title="Add chips to pot that others have to match">Bet</abbr> or <abbr title="Match an opponent bet">Call</abbr>

  - Down ↓ actions indicate a <abbr title="Pass, only possible when no one has made a bet">Check</abbr> or <abbr title="Surrender when facing a bet">Fold</abbr>
:::

Example betting round: 

- ![](assets/p1l.png) Player 1: Up ↑ (1 chip into pot)

- ![](assets/p2w.png) Player 2: Up ↑ (1 chip into pot)

- High Card wins +2 (+1 from the ante, +1 from the ↑ bet)

- If ![](assets/p1l.png) P1 has card A and ![](assets/p2w.png)P2 has card K, ![](assets/p1l.png) P1 wins

Hands can end in two ways: 

1. A <abbr title="Both players show cards and the highest wins">showdown</abbr> resulting from two ↑ (Bet and Call) or two ↓ actions (Check and Check). Then the player with the highest card wins the pot. 

2. A fold resulting from ↑ and ↓ actions (Bet and Fold). Then the ↑ (betting) player automatically wins the pot.

Here is a list of all possible betting sequences:  

| ![](assets/p1l.png) Player 1  | ![](assets/p2w.png) Player 2  | ![](assets/p1l.png) Player 1 | Winner       |
|------------|-----------|-----------|----------|
| Up ↑        | Down ↓      |          |![](assets/p1l.png) Player 1 (+1) |
| Up ↑        | Up ↑        |          |High Card Player (+2)|
| Down ↓     | Down ↓      |          |High Card Player (+1)|
| Down ↓      | Up ↑        | Down ↓     |![](assets/p2w.png) Player 2 (+1) |
| Down ↓      | Up ↑        | Up ↑       |High Card Player (+2)|

### Get Started with Kuhn 
- Play a few hands

- Get used to the game setup

- Think about which situations are automatic and which are not

## Kuhn Game Tree
We'll represent Kuhn poker in terms of a visual game tree. This will become infeasible for more complicated games, but here it will let us visualize what is going on.

Going forward, we will refer to Player 1 as <span class="player p1"></span> and Player 2 as <span class="player p2"></span>. 

First, deal a card to <span class="player p1"></span> and to <span class="player p2"></span>. Each possible deal of the cards forms a separate game node. For example, <span class=gamenode>AK</span> means that <span class="player p1"></span> has <span class=gamenode>A</span> and <span class="player p2"></span> has <span class=gamenode>K</span>:
    
<div id="tree_visualization_075"></div>
    
<span class="player p1"></span> will act first. He knows what his card is, but not what card <span class="player p2"></span> has, so he can be in one of 3 infosets. We'll name them <span class="p1 infoset">A_</span>, <span class="p1 infoset">K_</span>, and <span class="p1 infoset">Q_</span> based on what card he holds:
    
<div id="tree_visualization_100"></div>
    
At each infoset, <span class="player p1"></span> can choose <span class=action>↑Up</span> or <span class=action>↓Down</span>. Note that for example <span class=action>↑Up</span> from a certain infoset will take the same action probability for *both nodes*, so <span class="p1 infoset">A_↑</span> will take the same probability in <span class="p1 infoset">AK↑</span> and <span class="p1 infoset">AQ↑</span> since they are indistinguishable to <span class="player p1"></span>.

<div id="tree_visualization_150"></div>

Each <span class=action>↑Up</span> or <span class=action>↓Down</span> action will each take us to a distinct game node, based on a unique set of cards and action history:

<div id="tree_visualization_175"></div>

Next, <span class="player p2"></span> will act. He can observe his card and <span class="player p1"></span>'s first action, but not <span class="player p1"></span>'s card. <span class="player p2"></span>'s 6 infosets are identified by IDs like <span class="p2 infoset">_K↓</span> and <span class="p2 infoset">_Q↑</span> based on his card and previous actions. In this case the previous actions are <span class="player p1"></span>'s first action.
    
<div id="tree_visualization_200"></div>
    
At each of these infosets, <span class="player p2"></span> can choose <span class=action>↑Up</span> or <span class=action>↓Down</span>:
    
<div id="tree_visualization_250"></div>
    
If the actions were <span class=action>↓↑</span>, then <span class="player p1"></span> will have to act again (equivalent to acting after a Check and Bet). Otherwise, the game is now over (with a payoff determined by the cards and the action sequence). 

We write the payoffs from <span class="player p1"></span>'s perspective, and remember that <span class="player p2"></span>'s payoffs will be the inverse. 

You can refer to the sequence table above to recall the 5 sequences of betting, which end either in one player folding (after <span class=action>↑</span> and <span class=action>↓</span> actions) or high card winning at *showdown*, which results from either two <span class=action>↑</span> (Bet and Call) or <span class=action>↓</span> (Check and Check) actions. 

<div id="tree_visualization_275"></div>

 If <span class="player p1"></span> still has to act, he'll be in one of just three infosets, <span class="p1 infoset">A_↓↑</span>, <span class="p1 infoset">K_↓↑</span>, or <span class="p1 infoset">Q_↓↑</span>:
    
<div id="tree_visualization_300"></div>
    
...and can choose <span class=action>↑Up</span> or <span class=action>↓Down</span>...
    
<div id="tree_visualization_350"></div>
    
...but whatever he chooses, the game will end after that move. We now have the entire game tree for Kuhn Poker: 
    
<div id="tree_visualization_400a"></div>

## Kuhn Strategies
    
Each player's strategy can be completely described in terms of their action probabilities at each infoset&mdash;6 of them per player.

For example, let's consider <span class="player p1"></span>'s decision at the infoset <span class="infoset p1">K_↓↑</span>:</p>

When <span class="player p1"></span> is at <span class="infoset p1">K_↓↑</span>, he doesn't know whether the true state of the world is <span class=gamenode>KA_↓↑</span> or <span class=gamenode>KQ_↓↑</span>. This is what that setting looks like in the game from <span class="player p1"></span>'s perspective: 

![](assets/k_down_up.png)

Whatever action (or randomized mix of actions) his strategy says to make, he will be doing so in all of situations where he arrives at <span class="infoset p1">K_↓↑</span>, without the ability to do different things for the different underlying states.

If both players play randomly (50% <span class=action>↑Up</span> on each action), then <span class="player p1"></span> will arrive at <span class="infoset p1">K_↓↑</span> via <span class=gamenode>KA↓↑</span> equally often as via <span class=gamenode>KQ↓↑</span>. 

<div class="duplicate_K_↓↑"></div>

In this case, his expected payoff for playing <span class=action>↑Up</span> is a 50%-50% weighted sum of the payoffs <span class=gamenode>KA↓↑↑</span> (<span class="player_label p1">-2</span> calling with <span class=gamenode>K</span> when opponent has <span class=gamenode>A</span>) and <span class=gamenode>KQ↓↑↑</span> (<span class="player_label p1">+2</span>, calling with <span class=gamenode>K</span> when opponent has <span class=gamenode>Q</span>), for an expected value of <span class="player_label p1">0</span>. 

Similarly, his expected payoff for <span class=action>↓Down</span> is a 50%-50% weighted sum of the payoffs for <span class=gamenode>KA↓↑↓</span> and <span class=gamenode>KQ↓↑↓</span>, though in this case they're both <span class="player_label p1">-1</span> and the EV doesn't depend on the composition weights of the infoset (since this is equivalent to always folding).

With these expected values, <span class="player p1"></span>'s "best response" at this infoset (holding everything else about both strategies constant) is to play <span class=action>↑Up</span> 100% of the time.

:::{.callout-note  appearance="minimal"}
## Exercise

How much should <span class="player p1"></span>'s expected value from the whole game (a random deal) increase if he moves from playing <span class=action>↑Up</span> (i.e. always calling the Bet) at <span class="infoset p1">K_↓↑</span> 50% of the time to 100% instead? Once you've figured out what you expect the answer to be, set the strategy probability to 100% in the text box above and check your answer.
:::
      
But what if the probabilities of reaching <span class="infoset p1">K_↓↑</span> via <span class=gamenode>KA↓↑</span> versus <span class=gamenode>KQ↓↑</span> aren't equal? If the players don't play 50-50 randomly, then we'll have to calculate the probability of reaching <span class=gamenode>KA↓↑</span> (including the probability of the initial <span class=gamenode>KA</span> deal) and the probability of reaching <span class=gamenode>KQ↓↑</span> (likewise), and let the composition of the infoset be proportional to the the probabilities of reaching these states. We can see this in our next example. *(In larger games, we might approximate these reach-state probabilities by sampling games with simulated play instead of calculating them analytically.)*

Consider <span class="player p2"></span>'s actions at <span class="infoset p2">_Q↓</span> (the poker situation of having a <span class=gamenode>Q</span> facing a Check). <span class="player p2"></span> will always get a payoff of <span class="player_label p2">-1.0</span> (<span class="player_label p1">+1.0</span>) if he plays <span class=action>↓Down</span> (Folding). 

When <span class="player p1"></span> plays randomly at <span class="infoset p1">K_↓↑</span> (the poker situation of having a <span class=gamenode>K</span> and Checking and then facing a Bet), then <span class="player p2"></span> will get a payoff of <span class="player_label p2">-0.5</span> (<span class="player_label p1">+0.5</span>) if he played <span class=action>↑Up</span> (always Betting) since half the time <span class="player p1"></span> will play <span class=action>↓Down</span> (Fold, <span class="player_label p2">+1</span>) and half the time he will <span class=action>↑Up</span> (Call, <span class="player_label p2">-2</span>). 

Note that <span class="player p2"></span>'s <span class=gamenode>Q</span> is always has the worst hand and an <span class=action>↑Up</span> action is a <abbr title ="Betting with a weak hand with the goal of making the opponent fold">*bluff*</abbr>, but if <span class="player p1"></span> plays <span class=action>↓Down</span> (Folds) often enough, then <span class="player p2"></span> will win <span class="player_label p2">+1</span>s often enough to come out ahead regardless.

But if <span class="player p1"></span> always plays <span class=action>↑Up</span> at <span class="infoset p1">K_↓↑</span>, then <span class="player p2"></span>'s payoff for playing <span class=action>↑Up</span> at <span class="infoset p2">_Q↓</span> becomes <span class="player_label p2">-1.25</span> (<span class="player_label p1">+1.25</span>), worse than playing <span class=action>↓Down</span>, and so he should play <span class=action>↓Down</span> instead of <span class=action>↑Up</span>.

<div class="duplicate_K_↓↑" style="display:inline-block"></div>

<div class="duplicate__Q↓" style="display:inline-block"></div>

:::{.callout-note  appearance="minimal"}
## Exercise

Set the <span class="infoset p1">K_↓↑</span> strategy prob to <span class="player p1"></span>'s local best response. Set the <span class="infoset p2">_Q↓</span> strategy prob to <span class="player p2"></span>'s local best response. Observe that <span class="player p1"></span>'s best-response has changed again. Try to set the strategies to a pair of values such that neither player has regret.
:::

Now we get to the core difference between solving perfect information games and imperfect information games. In our game of Kuhn poker, when <span class="player p2"></span> switches to only playing <span class=action>↓Down</span> at <span class="infoset p2">_Q↓</span>, <span class="player p1"></span>'s payoff EVs at <span class="infoset p1">K_↓↑</span> change&mdash;because now that infoset is only composed of <span class="gamenode">KA↓↑</span> and no <span class="gamenode">KQ↓↑</span>. 

With the resulting EVs, <span class="player p1"></span> has a payoff of <span class="player_label p1">-2</span> for playing <span class=action>↑Up</span>, and should play <span class=action>↓Down</span> instead. 

In a perfect information game, we can solve the game inductively by passing up the tree from the end-states and solving each situation in terms of known solutions to its successor nodes. Whatever the best thing to do at the downtree node was, it's still the best thing to do, no matter how you get there.

But in an imperfect information game, changing an uptree strategy parameter can change the "right solution" is at downtree infosets, so we can't solve a game in a single pass from the endgames to the beginning. Nearly every game-solving technique for imperfect information games, then, is based on iteratively improving on a pair of strategies (one for each player) based on local improvements until it hopefully resolves into something good.

:::{.callout-note  appearance="minimal"}
## Exercise

Now try to find a pair of no-regret full strategies for <span class="player p1"></span> and <span class="player p2"></span>. When you get each infoset to at most 0.1 chips of EV away from regret-free, a link to the next stage will appear here:
:::
      
<script>
  function unlock_next() {
    document.getElementById("unlock_next").style.display = "";
    document.getElementById("cheat_unlock_next").style.display = "none";
  };
</script>
    
<button id="cheat_unlock_next" onclick="unlock_next()">Cheat</button>

<div id="unlock_next" style="display:none">
  <p><a href=https://www.youtube.com/watch?v=dQw4w9WgXcQ>Here</a> is the link to the next stage.</p>
</div>
    
<div id="tree_visualization_400b"></div>

<div style="display:none">
  <div style="display: inline-block; margin: 1em;">
      <button id="start_simulator" style="padding: 0.5em 1em;" onclick="startSimulator()">Run Solver</button>
  </div>
  <div style="display: inline-block; margin: 1em;">
      <label for="update_mode" style="margin-right: 0.5em;">Update mode:</label>
      <select id="update_mode" style="padding: 0.2em;">
          <option value="1.0" selected="selected">100% CFR</option>
          <option value="0.1">10% CFR</option>
          <option value="0.01">1% CFR</option>
          <option value="0.001">0.1% CFR</option>
          <option value="0.0001">0.0001% CFR</option>
          <option value="0.00001">0.00001% CFR</option>
      </select>
  </div>

<div style="display: inline-block; margin: 1em;">
    <label for="num_iterations" style="margin-right: 0.5em;">Iterations:</label>
    <select id="num_iterations" style="padding: 0.2em;">
        <option value="1" selected="selected">1</option>
        <option value="10">10</option>
        <option value="100">100</option>
        <option value="1000">1,000</option>
        <option value="10000">10,000</option>
        <option value="100000">100,000</option>
    </select>
</div>
      
<div style="display: inline-block; margin: 1em;">
    <label for="wait_per_step" style="margin-right: 0.5em;">Speed:</label>
    <select id="wait_per_step" style="padding: 0.2em;">
        <option value="0" selected="selected">Max</option>
        <option value="10">Fast</option>
        <option value="100">10/sec</option>
        <option value="1000">1/sec</option>
    </select>
</div>
      
<div style="display: inline-block; margin: 1em;">
    <label for="tolerance" style="margin-right: 0.5em;">Tolerance:</label>
    <select id="tolerance" style="padding: 0.2em;">
        <option value="0.01">0.01</option>
        <option value="0.03">0.03</option>
        <option value="0.1" selected="selected">0.1</option>
        <option value="0.3">0.3</option>
    </select>
</div>

</div>
    
<div id="subtree_visualization" style="max-width: 960px;"></div>
    
<em><strong style="color:red">Todo (solver stage):</strong> <ul>
      <li>split off auto-solver page</li>
      <li>add update modes to auto-solver</li>
      <li>add "unlock" to auto-solver</li>
      <li>add leaderboard</li>
      <li>add "submit" button</li>
      <li>receive submissions on backend</li>
      <li>auto-run tournaments (on submission?)</li>
      <li>set up instructor bot submissions</li>
      <li><del>add pause button to solver</del></li>
    </ul></em></p>

```{=html}
<script src="index.js"></script>
<script>
  /* global create_tree */
  create_tree("tree_visualization_075", 0.75);
  create_tree("tree_visualization_100", 1.0);
  create_tree("tree_visualization_150", 1.50);
  create_tree("tree_visualization_175", 1.75);
  create_tree("tree_visualization_200", 2.0);
  create_tree("tree_visualization_250", 2.5);
  create_tree("tree_visualization_275", 2.75);
  create_tree("tree_visualization_300", 3.0);
  create_tree("tree_visualization_350", 3.5);
  create_tree("tree_visualization_400a", 4.0);
  create_tree("tree_visualization_400b", 4.0, true);
</script>
```

## OLD STUFF! 

### Play
Recall the two types of uncertainty: 

1. About which node we are actually in, which depends on probabilities upwards in the game tree

2. About what happens after an action, which depends on the probabilities downwards in the game tree

## Challenge 1
The goal of this challenge is to find optimal strategies for Kuhn Poker by adjusting the individual strategies at each of the 12 infosets (6 for each player). Optimal here means Nash equilibrium regret-minimizing strategies for both players. 

By adjusting strategies for both players, we can find an equilibrium and then 

### Part 1: Submit Manual Strategies
Set the 12 strategies to percentages that you think are best. 

Hint: There are some "automatic" infoset strategies such that it only makes sense to play 100% of one action in the game. 

TODO: Time limit? Do this in session and other outside? 

### Part 2: Submit Automatic Strategies
After submitting the manual strategies, you will move to the automatic page in which you can update the strategies by selecting different algorithmic methods, iterations, and speeds. 

#### Why can’t we just do tree search?

Because of incomplete information.

If we had complete information, then the regret-minimizing strategy downstream of a node would depend only on stuff downtree of that node, and we could – in theory – compute the strategy recursively from the bottom up.

If you attempt to follow this strategy in Kuhn poker, it will fail. You can try this for yourself – if it was valid to “solve from the bottom up”, then the following steps should get to a regret-minimal strategy: 

1. Reset
2. Update the strategy weights for the X_↓↑ nodes until they converge.
3. Update the strategy weights for the _X↓ and _X↑ nodes until they converge.
4. Update the strategy weights for the X_ nodes until they converge.

Follow these steps. You do not have a regret-minimal strategy. Why not? What went wrong? 

#### Do we really need mixed strategies?

You can test this for yourself. If you set the learning rate to 1.0, updating a cell will move it all the way to playing the locally better action 100% of the time.

Follow these steps:

1. Reset
2. Set the learning rate to 1.0.
3. In any order you like, pick cells and update them.
4. Repeat 3 while there are still suboptimal moves in your strategy.

A bad thing is happening to you. Why?

#### Find Strategies
Update the strategies until they converge and submit the strategy. 

### Challenge 1 Results
Parts 1 and 2 will each generate and submit a bot that plays with your chosen probabilities. (It has no memory of other rounds, and plays each round based on the probabilities.) 

Your submission will play 100,000 times against all other submissions (including 10 bots that we added to start the challenge). It will play as P1 half the time and P2 half the time. Each 1v1 will be played in duplicate so that the card dealings are reversed to reduce variance. 

After a short delay, the leaderboard should update; your score will be compared to other players and selected bots. You will be listed as “tied” with another entry if your total score against all opponents is within one standard error of theirs.