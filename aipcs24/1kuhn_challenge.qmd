---
title: "Kuhn Poker (1): Challenge"
sidebar: aipcs24
format:
  html:
    math: true
    css: styles.css
---
```{=html}
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="index.js"></script>
```
## UNDER CONSTRUCTION! 

This is a staging / draft page for material which will ultimately live in the AIPCS24 handout for Lesson 1.
Todo: Should there be an introductory explanation of Kuhn poker that goes here first?
We'll represent Kuhn poker in terms of a visual game tree. This will become infeasible for more-complicated games, but here it will let us visualize what is going on.
First, deal a card to <span class="player p1"></span> and to <span class="player p2"></span>. Each possible deal of the cards forms a separate game node; for example, <span class=gamenode>AK</span> means that <span class="player p1"></span> has <span class=card>A</span> and <span class="player p2"></span> has <span class=card>K</span>:

::: {#tree_visualization_075}
:::

<span class="player p1"></span> will act first. He knows what his card is, but not what card <span class="player p2"></span> has, so he can be in one of three infosets. We'll name them <span class="p1 infoset">A_</span>, <span class="p1 infoset">K_</span>, and <span class="p1 infoset">Q_</span> based on what card he holds:

::: {#tree_visualization_100}
:::

At each infoset, <span class="player p1"></span> can choose <span class=action>↑Up</span> or <span class=action>↓Down</span>...

::: {#tree_visualization_150}
:::

...which will each take us to a distinct game node, based on a unique set of cards and action history:

::: {#tree_visualization_175}
:::

Next, <span class="player p2"></span> will act. He can observe his card and <span class="player p1"></span>'s first action, but not <span class="player p1"></span>'s card. We'll name <span class="player p2"></span>'s six infosets with names like <span class="p2 infoset">_K↓</span> and <span class="p2 infoset">_Q↑</span> after his card and <span class="player p1"></span>'s first action:

::: {#tree_visualization_200}
:::

At each of these infosets, <span class="player p2"></span> can choose <span class=action>↑Up</span> or <span class=action>↓Down</span>:

::: {#tree_visualization_250}
:::

If the actions were <span class=action>↓↑</span>, then <span class="player p1"></span> will have to act again. Otherwise, the game is now over (with a payoff determined by the cards and the action sequence). We'll write the payoffs from <span class="player p1"></span>'s perspective, and remember that <span class="player p2"></span>'s payoffs will be the inverse.

::: {#tree_visualization_275}
:::

If <span class="player p1"></span> still has to act, he'll be in one of just three infosets, <span class="p1 infoset">A_↓↑</span>, <span class="p1 infoset">K_↓↑</span>, or <span class="p1 infoset">Q_↓↑</span>:

::: {#tree_visualization_300}
:::

...and can choose <span class=action>↑Up</span> or <span class=action>↓Down</span>...

::: {#tree_visualization_350}
:::

...but whatever he chooses, the game will end after that move:

::: {#tree_visualization_400a}
:::

Each player's strategy can be completely described in terms of their action probabilities at each infoset—six of them total. For example, let's consider <span class="player p1"></span>'s decision at the infoset <span class="infoset p1">K_↓↑</span>:

::: {.duplicate_K_↓↑}
:::

When <span class="player p1"></span> is at <span class="infoset p1">K_↓↑</span>, he doesn't know whether the true state of the world is <span class=gamenode>KA_↓↑</span> or <span class=gamenode>KQ_↓↑</span>. Whatever action (or randomized mix of actions) his strategy says to make, he will be doing so in all of situations where he arrives at <span class="infoset p1">K_↓↑</span>, without the ability to do different things for the different underlying states.
If both players play randomly (50% <span class=action>↑Up</span> on each action), then <span class="player p1"></span> will arrive at <span class="infoset p1">K_↓↑</span> via <span class=gamenode>KA↓↑</span> equally often as via <span class=gamenode>KQ↓↑</span>. In this case, his expected payoff for playing <span class=action>↑Up</span> is a 50%-50% weighted sum of the payoffs <span class=gamenode>KA↓↑↑</span> (<span class="player_label p1">-2</span>) and <span class=gamenode>KQ↓↑↑</span> (<span class="player_label p1">+2</span>), for an expected value of <span class="player_label p1">0</span>. Similarly, his expected payoff for <span class=action>↓Down</span> is a 50%-50% weighted sum of the payoffs for <span class=gamenode>KA↓↑↓</span> and <span class=gamenode>KQ↓↑↓</span>, though in this case they're both <span class="player_label p1">-1</span> and the EV doesn't depend on the composition weights of the infoset.
With these expected values, <span class="player p1"></span>'s "best response" at this infoset (holding everything else about both strategies constant) is to play <span class=action>↑Up</span> 100% of the time.
Exercise: How much should <span class="player p1"></span>'s expected value from the whole game (a random deal) to increase if he moves from playing <span class=action>↑Up</span> at <span class="infoset p1">K_↓↑</span> 50% of the time to 100% instead? Once you've figured out what you expect the answer to be, set the strategy probability to 100% in the text box above and check your answer.
But what if the probabilities of reaching <span class="infoset p1">K_↓↑</span> via <span class=gamenode>KA↓↑</span> versus <span class=gamenode>KQ↓↑</span> aren't equal? If the players don't play 50-50 randomly, then we'll have to calculate the probability of reaching <span class=gamenode>KA↓↑</span> (including the probability of the initial <span class=gamenode>KA</span> deal) and the probability of reaching <span class=gamenode>KQ↓↑</span> (likewise), and let the composition of the infoset be proportional to the reach-state probabilities. [note: in larger games, we might approximate these reach-state probabilities by sampling games with simulated play instead of calculating them analytically] We can see this in our next example.
Consider <span class="player p2"></span>'s actions at <span class="infoset p2">_Q↓</span>. When <span class="player p1"></span> played <span class="infoset p1">K_↓↑</span> randomly, <span class="player p2"></span> would get a payoff of <span class="player_label p2">-1.0</span> (<span class="player_label p1">+1.0</span>) for playing <span class=action>↓Down</span> and <span class="player_label p2">-0.5</span> (<span class="player_label p1">+0.5</span>) for playing <span class=action>↑Up</span>. <span class="player p2"></span>'s <span class=card>Q</span> is always has the worst hand, but if <span class="player p1"></span> plays <span class=action>↓Down</span> [the poker term would be that he "folds"] often enough, then <span class="player p2"></span> will win <span class="player_label p2">+1</span>s often enough to come out ahead regardless.
But if <span class="player p1"></span> always plays <span class=action>↑Up</span> at <span class="infoset p1">K_↓↑</span>, then <span class="player p2"></span>'s payoff for playing <span class=action>↑Up</span> at <span class="infoset p2">_Q↓</span> becomes <span class="player_label p2">-1.25</span> (<span class="player_label p1">+1.25</span>), worse than playing <span class=action>↓Down</span>, and so he should play <span class=action>↓Down</span> instead of <span class=action>↑Up</span>.

::: {.duplicate_K_↓↑ style="display:inline-block"}
:::

::: {.duplicate__Q↓ style="display:inline-block"}
:::

Exercise: Set the <span class="infoset p1">K_↓↑</span> strategy prob to <span class="player p1"></span>'s local best response. Set the <span class="infoset p2">_Q↓</span> strategy prob to <span class="player p2"></span>'s local best response. Observe that <span class="player p1"></span>'s best-response has changed again. Try to set the strategies to a pair of values such that neither player has regret.
Now we get to the core difference between solving complete-information games and incomplete-information games. In our game of Kuhn poker, when <span class="player p2"></span> switches to only playing <span class=action>↓Down</span> at <span class="infoset p2">_Q↓</span>, <span class="player p1"></span>'s payoff EVs at <span class="infoset p1">K_↓↑</span> change—because now that infoset is only composed of <span class="gamenode">KA↓↑</span> and no <span class="gamenode">KQ↓↑</span>. With the resulting EVs, <span class="player p1"></span> has a payoff of <span class="player_label p1">-2</span> for playing <span class=action>↑Up</span>, and should play <span class=action>↓Down</span> instead. In a complete-information game, we can solve the game inductively by passing up the tree from the end-states and solving each situation in terms of known solutions to its successor nodes. Whatever the best thing to do at the downtree node was, it's still the best thing to do, no matter how you get there.
But in an imperfect-information game, changing an uptree strategy parameter can change the "right solution" is at downtree infosets—so we can't solve a game in a single pass from the endgames to the beginning. Nearly every game-solving technique for imperfect-information games, then, is based on iteratively improving on a pair of strategies (one for each player) based on local improvements until it hopefully resolves into something good.
Exercise: Now try to find a pair of regret-free full strategies for <span class="player p1"></span> and <span class="player p2"></span>. When you get each infoset to at most 0.1 chips of EV away from regret-free, a link to the next stage will appear here:

::: {#unlock_next style="display:none"}
Here is the link to the next stage.
:::

::: {#tree_visualization_400b}
:::

<script>
document.addEventListener("DOMContentLoaded", function() {
  create_tree("tree_visualization_075", 0.75);
  create_tree("tree_visualization_100", 1.0);
  create_tree("tree_visualization_150", 1.50);
  create_tree("tree_visualization_175", 1.75);
  create_tree("tree_visualization_200", 2.0);
  create_tree("tree_visualization_250", 2.5);
  create_tree("tree_visualization_275", 2.75);
  create_tree("tree_visualization_300", 3.0);
  create_tree("tree_visualization_350", 3.5);
  create_tree("tree_visualization_400a", 4.0);
  create_tree("tree_visualization_400b", 4.0, true);
});

function unlock_next() {
  document.getElementById("unlock_next").style.display = "";
}
</script>

## Kuhn Poker
Kuhn Poker is the most simple version of poker. Here is the setup: 

- 3 card deck: Queen, King, Ace (in ascending order, so Ace is highest)

:::{.callout-tip collapse="true"  appearance="minimal"}
## Alternative Decks 

  - Any deck of 3 ranked cards works

  - This could be numbers like {0, 1, 2} or other cards like {Jack, Queen, King}
:::

- 2 players

- Each player starts with 2 <abbr title="Betting currency -- the goal is to win these">chips</abbr> and <abbr title="An ante is a forced bet">antes</abbr> 1 chip

- Deal 1 card to each player (discard the third)

![](assets/kuhn.png)

- There is one betting round in which players can take these actions: 

  - Up ↑ (putting a chip into the pot) 
  
  - Down ↓ (not putting a chip into the pot) 

:::{.callout-tip collapse="true"  appearance="minimal"}
## Poker Terms for Actions 

  - Up ↑ actions indicate a <abbr title="Add chips to pot that others have to match">Bet</abbr> or <abbr title="Match an opponent bet">Call</abbr>

  - Down ↓ actions indicate a <abbr title="Pass, only possible when no one has made a bet">Check</abbr> or <abbr title="Surrender when facing a bet">Fold</abbr>
:::

Example betting round: 

- ![](assets/p1l.png) Player 1: Up ↑ (1 chip into pot)

- ![](assets/p2w.png) Player 2: Up ↑ (1 chip into pot)

- High Card wins +2 (+1 from the ante, +1 from the ↑ bet)

- If ![](assets/p1l.png) P1 has card A and ![](assets/p2w.png)P2 has card K, ![](assets/p1l.png) P1 wins

List of all possible betting sequences: 

| ![](assets/p1l.png) Player 1  | ![](assets/p2w.png) Player 2  | ![](assets/p1l.png) Player 1 | Winner       |
|------------|-----------|-----------|----------|
| Up ↑        | Down ↓      |          |![](assets/p1l.png) Player 1 (+1) |
| Up ↑        | Up ↑        |          |High Card Player (+2)|
| Down ↓     | Down ↓      |          |High Card Player (+1)|
| Down ↓      | Up ↑        | Down ↓     |![](assets/p2w.png) Player 2 (+1) |
| Down ↓      | Up ↑        | Up ↑       |High Card Player (+2)|

### Get Started with Kuhn 
- Play a few hands

- Get used to the game setup

- Think about which situations are automatic and which are not

## Interactive Site
Visit the [interactive Kuhn site](https://static.rossry.net/sketches/poker/kuhn3/). The site shows the game tree for Kuhn Poker at the top and the 12 information sets of the game at the bottom. 

### Interactive Site Kuhn Tree
Recall that an information set is a set of nodes that contain the same information for the corresponding player. For example, a ![](assets/p1l.png) P1 K_ node indicates that ![](assets/p1l.png) P1 has card K and no other actions have occurred (if actions had occurred they would be shown in the infoset as ↑ or ↓). 

This information set represents both the node where ![](assets/p1l.png) P1 has K and ![](assets/p2w.png) P2 has A and the node where ![](assets/p1l.png) P1 has K and ![](assets/p2w.png) P2 has Q, but since ![](assets/p1l.png) P1 cannot distinguish between these, they are grouped into one information set. 

TODO: Screenshots and explain

### Interactive Site Node Strategies
TODO: Screenshots and explain

### Play
Spend a few minutes playing with the strategy probabilities to see how they affect the rest of the tree.

Recall the two types of uncertainty: 

1. About which node we are actually in, which depends on probabilities upwards in the game tree

2. About what happens after an action, which depends on the probabilities downwards in the game tree

## Challenge 1
The goal of this challenge is to find optimal strategies for Kuhn Poker by adjusting the individual strategies at each of the 12 infosets (6 for each player). Optimal here means Nash equilibrium regret-minimizing strategies for both players. 

By adjusting strategies for both players, we can find an equilibrium and then 

### Part 1: Submit Manual Strategies
Set the 12 strategies to percentages that you think are best. 

Hint: There are some "automatic" infoset strategies such that it only makes sense to play 100% of one action in the game. 

TODO: Time limit? Do this in session and other outside? 

### Part 2: Submit Automatic Strategies
After submitting the manual strategies, you will move to the automatic page in which you can update the strategies by selecting different algorithmic methods, iterations, and speeds. 

#### Why can’t we just do tree search?

Because of incomplete information.

If we had complete information, then the regret-minimizing strategy downstream of a node would depend only on stuff downtree of that node, and we could – in theory – compute the strategy recursively from the bottom up.

If you attempt to follow this strategy in Kuhn poker, it will fail. You can try this for yourself – if it was valid to “solve from the bottom up”, then the following steps should get to a regret-minimal strategy: 

1. Reset
2. Update the strategy weights for the X_↓↑ nodes until they converge.
3. Update the strategy weights for the _X↓ and _X↑ nodes until they converge.
4. Update the strategy weights for the X_ nodes until they converge.

Follow these steps. You do not have a regret-minimal strategy. Why not? What went wrong? 

#### Do we really need mixed strategies?

You can test this for yourself. If you set the learning rate to 1.0, updating a cell will move it all the way to playing the locally better action 100% of the time.

Follow these steps:

1. Reset
2. Set the learning rate to 1.0.
3. In any order you like, pick cells and update them.
4. Repeat 3 while there are still suboptimal moves in your strategy.

A bad thing is happening to you. Why?

#### Find Strategies
Update the strategies until they converge and submit the strategy. 

### Challenge 1 Results
Parts 1 and 2 will each generate and submit a bot that plays with your chosen probabilities. (It has no memory of other rounds, and plays each round based on the probabilities.) 

Your submission will play 100,000 times against all other submissions (including 10 bots that we added to start the challenge). It will play as P1 half the time and P2 half the time. Each 1v1 will be played in duplicate so that the card dealings are reversed to reduce variance. 

After a short delay, the leaderboard should update; your score will be compared to other players and selected bots. You will be listed as “tied” with another entry if your total score against all opponents is within one standard error of theirs.