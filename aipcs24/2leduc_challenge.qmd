---
title: "#2: Leduc Poker | Challenge"
sidebar: aipcs24
format:
  html:
    math: true
---
## Leduc Poker
Slightly more advanced than Kuhn

## Types of Games

:::{.callout-note  appearance="minimal"}
## Exercise
Fill in the table below with games you know about. Thanks to Eliezer for getting us started. 
:::

| Game/Opponent     | Fixed/Probabilistic Opponent | Adversarial Opponent | 
|------------|-----------|--------|
| **Imperfect Info, No Player Agency/Decisions**      | ![](assets/eliezer_snakes.jpg)          |
| **Perfect Info, Player Actions Always Perfect Info**     |  |
| **Imperfect Info, Imperfect from Randomness**     |   |
| **Imperfect Info, Imperfect from Randomness AND Game States**    |   |

:::{.callout-tip collapse="true"  appearance="minimal"}
## Pre-Filled Table

| Game/Opponent     | Fixed/Probabilistic Opponent | Adversarial Opponent | 
|------------|-----------|--------|
| Imperfect Info, No Player Agency/Decisions      | Candy Land, War, Dreidel, Bingo, Chutes and Ladders, Slot machine          |
| Perfect Info, Player Actions Always Perfect Info     | Puzzles  | Tictactoe, Checkers, Chess, Arimaa, Go |
| Imperfect Info, Imperfect from Randomness     | Blackjack   | Backgammon |
| Imperfect Info, Imperfect from Randomness AND Game States    | Partial Info Multi-armed Bandit   | Poker, Rock Paper Scissors, Liar’s Dice, Figgie |

:::

What about solitaire? With Blackjack?
What about a lottery? 
Mahjong?
Tennis value of states in RL 

Pure strategies in perfect info games vs. mixed in imperfect info

Deterministic Nature: Because all players can see the entire game state and know all possible moves, strategies can be deterministic. Players can calculate and choose the optimal move based on this complete information.
Pure Strategies: A pure strategy is a complete plan of action for every possible situation in a game. In perfect information games, players can follow a pure strategy because they know exactly what will happen as a result of each possible move.

Uncertainty and Hidden Information: Because players cannot see the entire game state, they must account for uncertainty and the hidden information of their opponents. This makes the game more about probabilities and expectations rather than certainties.
Mixed Strategies: A mixed strategy involves randomizing over possible moves to prevent opponents from exploiting predictable patterns. By using mixed strategies, players can become less predictable and make it more difficult for opponents to formulate a counter-strategy.

Strategic Randomization: In games like poker, where bluffing and deception play significant roles, mixed strategies are essential. For example, a player might choose to bluff (make a bet with a weak hand) with a certain probability to keep opponents guessing and to avoid being exploited by always playing in a predictable manner.

(Ross note: The difference between “Chance” and “Imperfect Info” is that in Chance, the unknown [thing] doesn’t affect anything about the world until it becomes known, and then it’s not unknown any more. In Imperfect Info, the information has some effect on the world at time T1, then you need to make a decision at time T2, then the information will matter at some later point T3.)

:::{.callout-note  appearance="minimal"}
## Exercise
What makes poker and other games in the bottom right of the table interesting? 

:::

## Simulator

Random, reward avg, etc. 

Describe the exploration vs. exploitation dilemma.
Introduce basic strategies: epsilon-greedy, UCB (Upper Confidence Bound), and Thompson Sampling.

Record the results and display them in real-time (either through the program or manually on a board).
Strategy Discussion:

After a few rounds, pause and discuss the strategies teams are using.
Introduce the different algorithms and how they would approach the problem.

Algorithm Implementation:

Allow teams to adopt one of the introduced algorithms for the next rounds.
Compare the performance of different algorithms in terms of accumulated rewards.

<div id="bandit-container">
  <table id="bandit-table">
    <thead>
      <tr>
        <th>Arm</th>
        <th>Average Reward</th>
        <th>Pulls</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody id="arms-container">
    </tbody>
  </table>
  <div id="stats-container"></div>
  <button id="reset-button">Reset</button>
</div>
<!-- <div id="debug-output"></div> -->

<script>
document.addEventListener('DOMContentLoaded', (event) => {
  // const debug = (message) => {
  //   document.getElementById('debug-output').innerHTML += message + '<br>';
  // };

  // debug('Script started');

  const armsContainer = document.getElementById('arms-container');
  const statsContainer = document.getElementById('stats-container');
  const resetButton = document.getElementById('reset-button');

  function gaussianRandom(mean = 0, stdev = 1) {
    let u = 0, v = 0;
    while(u === 0) u = Math.random();
    while(v === 0) v = Math.random();
    let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
    return num * stdev + mean;
  }

  function createBandit(numArms) {
    return {
      arms: Array.from({length: numArms}, (_, i) => ({
        id: i + 1,
        q: gaussianRandom(0, 1),
        pulls: 0,
        totalReward: 0,
        averageReward: 0
      })),
      totalPulls: 0,
      totalReward: 0
    };
  }

  let bandit = createBandit(10);

  function pullArm(armId, times = 1) {
    const arm = bandit.arms[armId - 1];
    let totalReward = 0;
    const actualPulls = Math.min(times, 1000 - bandit.totalPulls);
    for (let i = 0; i < actualPulls; i++) {
      const reward = gaussianRandom(arm.q, 1);
      arm.pulls++;
      arm.totalReward += reward;
      totalReward += reward;
      bandit.totalPulls++;
      bandit.totalReward += reward;
    }
    arm.averageReward = arm.totalReward / arm.pulls;
    return totalReward;
  }

  function updateStats() {
    statsContainer.innerHTML = `
      <p>Total Pulls: ${bandit.totalPulls}</p>
      <p>Total Reward: ${bandit.totalReward.toFixed(2)}</p>
      <p>Average Reward per Pull: ${(bandit.totalReward / bandit.totalPulls || 0).toFixed(2)}</p>
    `;
  }

  function createArmRows() {
    armsContainer.innerHTML = '';
    bandit.arms.forEach(arm => {
      const row = document.createElement('tr');
      
      const armIdCell = document.createElement('td');
      armIdCell.textContent = `Arm ${arm.id}`;
      
      const avgRewardCell = document.createElement('td');
      avgRewardCell.id = `arm-avg-${arm.id}`;
      avgRewardCell.textContent = arm.averageReward.toFixed(2);
      
      const pullsCell = document.createElement('td');
      pullsCell.id = `arm-pulls-${arm.id}`;
      pullsCell.textContent = arm.pulls;
      
      const actionsCell = document.createElement('td');
      ['1', '10', '100', 'Max'].forEach(pullAmount => {
        const button = document.createElement('button');
        button.textContent = pullAmount;
        button.onclick = () => {
          const pulls = pullAmount === 'Max' ? 1000 : parseInt(pullAmount);
          const reward = pullArm(arm.id, pulls);
          updateStats();
          createArmRows();
          // debug(`Pulled arm ${arm.id} ${pulls} times, total reward: ${reward.toFixed(2)}`);
        };
        actionsCell.appendChild(button);
      });
      
      row.appendChild(armIdCell);
      row.appendChild(avgRewardCell);
      row.appendChild(pullsCell);
      row.appendChild(actionsCell);
      
      armsContainer.appendChild(row);
    });
    // debug('Arm rows updated');
  }

  function resetBandit() {
    bandit = createBandit(10);
    updateStats();
    createArmRows();
    // debug('Bandit reset');
  }

  resetButton.onclick = resetBandit;

  createArmRows();
  updateStats();
  // debug('Initial setup complete');
});
</script>

<style>
#bandit-container {
  font-family: Arial, sans-serif;
  width: 100%;
  padding: 20px;
  box-sizing: border-box;
}

#bandit-table {
  width: 100%;
  border-collapse: collapse;
  margin-bottom: 20px;
}

#bandit-table th, #bandit-table td {
  border: 1px solid #ddd;
  padding: 8px;
  text-align: left;
}

#bandit-table th {
  background-color: #f2f2f2;
}

#bandit-table button {
  margin-right: 5px;
}

#stats-container {
  background-color: #f0f0f0;
  padding: 15px;
  border-radius: 5px;
  margin-bottom: 20px;
}

#reset-button {
  display: block;
  margin: 0 auto;
  padding: 10px 20px;
  font-size: 18px;
}

/* #debug-output {
  margin-top: 20px;
  padding: 10px;
  background-color: #f0f0f0;
  border: 1px solid #ccc;
} */
</style>

## Solving Poker Games

- Kuhn Normal Form

- Kuhn Game Tree

## CFR  

[Slides, what to include?](https://docs.google.com/presentation/d/11S85i83OVb8SbPRAs9i3ygyXrv7e4SsUXxBloc04iHM/edit)

