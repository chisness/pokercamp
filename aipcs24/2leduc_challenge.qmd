---
title: "#2: Leduc Poker | Challenge"
sidebar: aipcs24
format:
  html:
    math: true
    css: styles.css

---
## Leduc Poker
Leduc Poker is a simple toy poker game invented at the University of Alberta. 

[![Alberta's nearby Edmonton Airport is in the city of Leduc](assets/leducmap.png)](https://maps.app.goo.gl/REZLBC6odxpFhjmQ8)

Here is the setup: 

- 2 players

- 6 card deck: 2 Queens, 2 Kings, 2 Aces (in ascending order, so Ace is highest)

- Each player antes 1 chip

- Deal 1 card to each player

- Betting round 1 (preflop): 
  - There is a fixed bet size of 2 chips

- Deal a face up community card
  - Players make the best 2 card hand combining their card and the community card, meaning a pair is the best possible hand

- Betting round 2 (the flop): 
  - There is a fixed bet size of 4 chips

:::{.callout-important collapse="true" appearance="minimal"}
## Maximum bets per round rule in original version
The original version of Leduc Poker has a rule where the maximum bets per round is 2 (i.e. a bet and a raise), but we are not using that rule. 
:::

### Sample Leduc Hand and Leduc Math
Here is a Leduc game situation in which: 

- Both players anted 1 each
  - Pot = 2
- Preflop: P1 bets 2 and P2 calls
  - Pot = 6
- Flop: Community card K revealed. Player 1 bets 4. Player 2 to act.

![](assets/leducgame.png)

:::{.callout-note  appearance="minimal"}
## Leduc Strategy

What should Player 2 do here?
:::

:::{.callout-warning collapse="true" appearance="minimal"}
## Solution
Raise! Player 2 has the best possible hand because they have a pair.
:::

:::{.callout-note  appearance="minimal"}
## Leduc Infoset

What is Player 2's infoset? 

What will Player 1's infoset be after Player 2 acts?
:::

:::{.callout-warning collapse="true" appearance="minimal"}
## Solution
Player 2 infoset now: (P2)[_, K, K][Bet 2, Call 2][Bet 4]

In code/shorthand, this could look like: 

`(P2)[None, K, K][2, 2][4]`

This shows the player who is acting, the cards known to them, and the previous actions.

Player 1 infoset after Player 2 acts: (P1)[P1 card, _, K][Bet 2, Call 2][Bet 4, Raise to 8]

In code/shorthand, this could look like: 

`(P1)[P1 card, None, K][2, 2][4, 8]`
:::

:::{.callout-note  appearance="minimal"}
## Leduc Ties

How often will you and your opponent be dealt the same card? 
:::

:::{.callout-warning collapse="true" appearance="minimal"}
## Solution
First we find the total combinations of cards: 

${6\choose2} = \frac{6!}{4!*2!} = \frac{6*5}{2} = 15$

Then we count that there is exactly $1$ way to make Q/Q, $1$ way to make K/K, and $1$ way to make A/A. Therefore the probability of having the same hand as your opponent is $\frac{3}{15} = 0.2$. 
:::

:::{.callout-note  appearance="minimal"}
## Leduc Pairs

Suppose that you are dealt a K. How often will you hit a pair on the flop given that you see it? 
:::

:::{.callout-warning collapse="true" appearance="minimal"}
## Solution
There are $5$ unknown cards to you and $1$ of them matches yours for a pair, so the $\Pr(\text{Pair} \mid \text{See Flop}) = \frac{1}{5} = 0.2$

<!-- You have the same card as your opponent $20\%$ of the time, in which case you cannot get a pair. 

In the other cases, there are $4$ cards remaining in the deck and $1$ of them matches yours, so you have a $0.25$ chance in this case. 

$\Pr(\text{Pair} \mid \text{See Flop}) = 0.2*0 + 0.8*0.25 = 0.2$ -->

:::

## Kuhn Poker 100 Cards

Kuhn Poker with 100 cards plays the same as Kuhn Poker with 3 cards, but the cards are numbered from 1 to 100 (or 0 to 99). 

:::{.callout-note  appearance="minimal"}
## 100 Card Kuhn Infosets
Kuhn Poker with 3 cards has 6 infosets per player, 12 total.

How many infosets are in 100 card Kuhn Poker?
:::

:::{.callout-warning collapse="true" appearance="minimal"}
## Solution

These scale linearly and so with 100 cards there are 400 infosets since each card has 4 infosets:

 - P1 acting first
 - P2 facing an Up action
 - P2 facing a Down action
 - P1 after a Down-Up sequence

:::

## Challenges

:::{.callout-tip  appearance="minimal"}
## Basic Challenges

1. Submit an agent for 100 card Kuhn Poker. 

2. Submit an agent for Leduc Poker with a 50 chip starting stack. Bet limitations are capped only by the stack size (i.e. no limit of 2 bets per round, but no player can lose more than 50 chips per hand).

In both cases, your agent will play in a tournament against: 

  - Other student submissions. 
  - 5 bots generated by our solver derived from a range of iterations (i.e. some will be much closer to Nash equilibrium than others).

:::

:::{.callout-tip  appearance="minimal"}
## Kuhn Bonus Game Value Challenge
Find an equilibrium strategy for 100 card and 3 card Kuhn Poker and compare the game value in 100 card Kuhn Poker to 3 card Kuhn Poker. We can define game value as the expected value of the game to Player 1. 
:::

:::{.callout-tip  appearance="minimal"}
## Leduc Bonus Game Value Challenge
Find an equilibrium strategy for Leduc Poker and compare the game value to 100 card Kuhn Poker to 3 card Kuhn Poker. We can define game value as the expected value of the game to Player 1. 
:::

#### Kuhn Card Abstraction 

100 card Kuhn Poker is a good testbed for **card abstraction**. Card abstraction is a method for shrinking a large game to a more manageable size. Bet abstraction is another (but since we are only using fixed bet sizes, this is currently not applicable).  

:::{.callout-tip appearance="minimal"}
## Kuhn Bonus Abstraction Challenge

Abstract 100 card Kuhn Poker into 10 uniform buckets and find the game value. 

That is, buckets from cards 0-9, 10-19, ..., 90-99. This means for example that when you get dealt a card from 0-9 you cannot distinguish between these states when acting. (When you see payoffs they are based on the actual cards.)

Compare this to your previous 100 card and 3 card Kuhn Poker values. Is there a better way to configure the 10 buckets than uniform?
:::

## Poker Camp Solver

We have built a basic solver that can be run as follows from the solvers/default directory: 

`python3 solver.py --iter [iterations]` 

To run 1000 iterations: 

`python3 solver.py --iter 1000` 

Upon completing a solve, each infoset the solver has seen and the final strategy for that infoset are displayed. 

For example in 3 card Kuhn Poker, we get something like this: 

```
(P1)[0, None][Down, Up]: {Down: 1.0, Up: 0.0}
(P1)[0, None][]       : {Down: 0.8150489886962787, Up: 0.1849510113037213}
(P1)[1, None][Down, Up]: {Down: 0.36837888738186775, Up: 0.6316211126181323}
(P1)[1, None][]       : {Down: 0.8131365930381713, Up: 0.18686340696182863}
(P1)[2, None][Down, Up]: {Down: 0.0, Up: 1.0}
(P1)[2, None][]       : {Down: 0.37332197949312035, Up: 0.6266780205068797}
(P2)[None, 0][Down]   : {Down: 0.7737705468066861, Up: 0.22622945319331383}
(P2)[None, 0][Up]     : {Down: 1.0, Up: 0.0}
(P2)[None, 1][Down]   : {Down: 0.9714280084961201, Up: 0.028571991503879877}
(P2)[None, 1][Up]     : {Down: 0.35544435642226935, Up: 0.6445556435777307}
(P2)[None, 2][Down]   : {Down: 0.0, Up: 1.0}
(P2)[None, 2][Up]     : {Down: 0.0, Up: 1.0}
```

And in a table: 

| Player | Cards    | Actions       | Infoset Strategy                                        |
|--------|----------|---------------|-------------------------------------------------|
| P1     | [0, None] | [Down, Up]    | {Down: 1.0, Up: 0.0}                            |
| P1     | [0, None] | []            | {Down: 0.8150489886962787, Up: 0.1849510113037213} |
| P1     | [1, None] | [Down, Up]    | {Down: 0.36837888738186775, Up: 0.6316211126181323} |
| P1     | [1, None] | []            | {Down: 0.8131365930381713, Up: 0.18686340696182863} |
| P1     | [2, None] | [Down, Up]    | {Down: 0.0, Up: 1.0}                            |
| P1     | [2, None] | []            | {Down: 0.37332197949312035, Up: 0.6266780205068797} |
| P2     | [None, 0] | [Down]        | {Down: 0.7737705468066861, Up: 0.22622945319331383} |
| P2     | [None, 0] | [Up]          | {Down: 1.0, Up: 0.0}                            |
| P2     | [None, 1] | [Down]        | {Down: 0.9714280084961201, Up: 0.028571991503879877} |
| P2     | [None, 1] | [Up]          | {Down: 0.35544435642226935, Up: 0.6445556435777307} |
| P2     | [None, 2] | [Down]        | {Down: 0.0, Up: 1.0}                            |
| P2     | [None, 2] | [Up]          | {Down: 0.0, Up: 1.0}                            |

### Handout Solver Options

`def handle_new_iteration(self, iteration_num):`

- Called when iteration is about to begin.
    
`def handle_iteration_over(self, iteration_num):`

- Called when iteration is over.
    
`def get_root(self, iteration_num):`

- Returns the RoundState to start a new iteration at.

`def determine_infoset(self, info):`

- Called to ask for the canonical name of an infoset.
        
- You might use this to coalesce multiple gamehistories into the same infoset.
    
`def sample_actions(self, infoset, legal_actions):`

- legal_actions is a list of types; this function should give one or more instances of each type (it might be 'or more' if you need to try different bet sizes...)

`def get_sampling_policy(self, infoset):`

- Called to ask for the sampling policy at this infoset.
        
- You can let this vary by iteration #, if you like.

- Currently supported: "expand_all", "sample"

`def handle_new_samples(self, infoset, sampling_policy, samples, use_ev):`

- Called on each new set of samples produced for a node.
        
- You should use this opportunity to update your strategy probabilites (or whatever stored values they are derived from, like cumulative regrets)
    
`def get_training_strategy_probabilities(self, infoset, legal_actions):`

- Called to ask for the current probabilities that should be used in a training iteration.

    
`def get_final_strategy_probabilities(self, infoset, legal_actions):`

- Called to ask for the final probabilities to report.
        
- This might be different from get_training_probabilites if you wanted to average over multiple recent iterations.

## Solving Poker Games
Typically solving a 2-player poker game is defined as finding a Nash equilibrium strategy for both players. This is straightforward to define and has been the target of much poker research, but means finding a fixed strategy that doesn't adapt to opponents and might not be the most profitable strategy in a field of a variety of opponents. 

Small poker games can be solved through linear programming given a matrix of strategies at each information set and a matrix of payoffs (see [here](https://aipokertutorial.com/toy-poker-games/#solving-with-linear-programming) for more details). 

As we prepare to solve larger games, we start to look at iterative algorithms.

The core feature of the iterative algorithms is self-play by traversing the game tree over all **infosets** and tracking the strategies and regrets at each.

### Regret and EV

Regret is a measure of how much each strategy at an infoset is preferred and is used as a way to update strategies. 

For a given P1 strategy and P2 strategy, a player has regret when they take an action at an infoset that was not the highest-EV action at that infoset. 

:::{.callout-note  appearance="minimal"}
## Regret Exercise

![](assets/basictree.png)

What is the regret for each action? 

| Action     | Regret |
|------------|-----------|
| A      |           |
| B     |  |
| C     |   |
:::

:::{.callout-warning collapse="true"  appearance="minimal"}
## Solution

| Action     | Regret |
|------------|-----------|
| A      |  4         |
| B     | 2  |
| C     | 0  |

:::

:::{.callout-note  appearance="minimal"}
## Expected Value Exercise
![](assets/basictree.png)

If taking a uniform strategy at this node (i.e. $\frac{1}{3}$ for each action), then what is the expected value of the node? 

:::

:::{.callout-warning collapse="true"  appearance="minimal"}
## Solution
$\mathbb{E} = \frac{1}{3}*1 + \frac{1}{3}*3+\frac{1}{3}*5 = 0.33+1+1.67 = 3$
:::

:::{.callout-note  appearance="minimal"}
## Poker Regret Exercise
![](assets/basictree.png)

In poker games, the regret for each action is defined as the value for that action minus the expected value of the node. Give the regret values for each action under this definition. 

:::

:::{.callout-warning collapse="true"  appearance="minimal"}
## Solution

| Action     | Value | Poker Regret
|------------|-----------|-----------|
| A      |  1         |  -2         |
| B     | 3  |  0         |
| C     | 5  |  2         |

At a node in a poker game, the player prefers actions with higher regrets by this definition. 

:::

### Counterfactual Regret Minimization  
The most popular method for iteratively solving poker games is the Counterfactual Regret Minimization (CFR) algorithm. 

The handout solver does not exactly use CFR. You can make updates to the solver however you would like, including modifying it to become CFR. 

What is a counterfactual? 

**Actual event:** I didn’t bring an umbrella, and I got wet in the rain

**Counterfactual event:** If I had brought an umbrella, I wouldn’t have gotten wet

#### CFR Algorithm Parts 
- general algorithm
  - store: strategy, regret
  - regret matching
  - average strategy at end
  - CFR+, Linear CFR
  - sampling (external, sampling, chance, etc. )
