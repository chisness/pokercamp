<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.54">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Ultimate Guide to CFR – Poker Camp</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href=".././assets/favicon32.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-1R1JQVQ05N"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-1R1JQVQ05N', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="Ultimate Guide to CFR – Poker Camp">
<meta property="og:description" content="">
<meta property="og:site_name" content="Poker Camp">
<meta name="twitter:title" content="Ultimate Guide to CFR – Poker Camp">
<meta name="twitter:description" content="">
<meta name="twitter:creator" content="@pokercamporg">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src=".././assets/favicon32.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Poker Camp</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-camp-info" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Camp Info</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-camp-info">    
        <li>
    <a class="dropdown-item" href="../camp">
 <span class="dropdown-text">Optimal Decision Poker Camp</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../aicamp">
 <span class="dropdown-text">AI Poker Camp</span></a>
  </li>  
    </ul>
  </li>
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools tools-wide">
    <a href="https://forms.gle/xx1tZNbwpYBLASmQ8" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-mailbox2-flag"></i></a>
    <a href="https://discord.gg/KZQK2xN8Da" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-discord"></i></a>
    <a href="https://x.com/pokercamporg" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-twitter"></i></a>
    <a href="https://github.com/chisness/pokercamp" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">Ultimate Guide to CFR</li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../aipcs24" class="sidebar-item-text sidebar-link">
 <span class="menu-text">AIPC Summer 2024</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Challenges</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="false">
 <span class="menu-text">#1: Kuhn Poker</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../aipcs24/1kuhn_reading.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Optional Reading</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../aipcs24/1kuhn_rules.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Rules</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../aipcs24/1kuhn_challenge.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Challenge</span></a>
  </div>
</li>
          <li class="sidebar-item">
 <span class="menu-text">Challenge Review</span>
  </li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="false">
 <span class="menu-text">#2: Leduc Poker</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../aipcs24/2leduc_class.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Class Materials</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../aipcs24/2leduc_challenge.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Challenge</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../aipcs24/2leduc_leaderboard.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Leaderboard</span></a>
  </div>
</li>
          <li class="sidebar-item">
 <span class="menu-text">Challenge Review</span>
  </li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="false">
 <span class="menu-text">#3: Rock Paper Scissors</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../aipcs24/3rps_reading.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Class Materials</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../aipcs24/3rps_challenge.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Challenge</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../aipcs24/3rps_leaderboard.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Leaderboard</span></a>
  </div>
</li>
          <li class="sidebar-item">
 <span class="menu-text">Challenge Review</span>
  </li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="false">
 <span class="menu-text">#4: Royal Hold’em</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../aipcs24/4nlrhe_reading.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Class Materials</span></a>
  </div>
</li>
          <li class="sidebar-item">
 <span class="menu-text">Challenge</span>
  </li>
          <li class="sidebar-item">
 <span class="menu-text">Challenge Review</span>
  </li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="false">
 <span class="menu-text">#5: Coming soon…</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
 <span class="menu-text">Class Materials</span>
  </li>
          <li class="sidebar-item">
 <span class="menu-text">Challenge</span>
  </li>
          <li class="sidebar-item">
 <span class="menu-text">Challenge Review</span>
  </li>
      </ul>
  </li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true">
 <span class="menu-text">Configuration</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
 <span class="menu-text">General Setup</span>
  </li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../aipcs24/bots.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Building and Running Bots</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../aipcs24/solvers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Building and Running Solvers</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" role="navigation" aria-expanded="true">
 <span class="menu-text">About the Course</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../aipcs24/sessions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Sessions and Challenges</span></a>
  </div>
</li>
          <li class="sidebar-item">
 <span class="menu-text">Instructors and TAs</span>
  </li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#ultimate-guide-to-cfr" id="toc-ultimate-guide-to-cfr" class="nav-link active" data-scroll-target="#ultimate-guide-to-cfr">Ultimate Guide to CFR</a>
  <ul class="collapse">
  <li><a href="#tldr-cfr-explanation" id="toc-tldr-cfr-explanation" class="nav-link" data-scroll-target="#tldr-cfr-explanation">TLDR CFR Explanation</a>
  <ul class="collapse">
  <li><a href="#regret-and-strategies" id="toc-regret-and-strategies" class="nav-link" data-scroll-target="#regret-and-strategies">Regret and Strategies</a></li>
  <li><a href="#regret-matching" id="toc-regret-matching" class="nav-link" data-scroll-target="#regret-matching">Regret Matching</a></li>
  <li><a href="#rps-regret-matching-experiment" id="toc-rps-regret-matching-experiment" class="nav-link" data-scroll-target="#rps-regret-matching-experiment">RPS Regret Matching Experiment</a></li>
  <li><a href="#iterating-through-the-tree" id="toc-iterating-through-the-tree" class="nav-link" data-scroll-target="#iterating-through-the-tree">Iterating through the Tree</a></li>
  <li><a href="#alternativesupdates-to-original-algorithm" id="toc-alternativesupdates-to-original-algorithm" class="nav-link" data-scroll-target="#alternativesupdates-to-original-algorithm">Alternatives/Updates to Original Algorithm</a></li>
  </ul></li>
  <li><a href="#the-algorithm" id="toc-the-algorithm" class="nav-link" data-scroll-target="#the-algorithm">The Algorithm</a></li>
  <li><a href="#regret-bounds-and-convergence-rates" id="toc-regret-bounds-and-convergence-rates" class="nav-link" data-scroll-target="#regret-bounds-and-convergence-rates">Regret Bounds and Convergence Rates</a>
  <ul class="collapse">
  <li><a href="#why-average-strategy" id="toc-why-average-strategy" class="nav-link" data-scroll-target="#why-average-strategy">Why average strategy?</a></li>
  <li><a href="#vanilla-cfr" id="toc-vanilla-cfr" class="nav-link" data-scroll-target="#vanilla-cfr">Vanilla CFR</a></li>
  <li><a href="#monte-carlo-cfr-mccfr" id="toc-monte-carlo-cfr-mccfr" class="nav-link" data-scroll-target="#monte-carlo-cfr-mccfr">Monte Carlo CFR (MCCFR)</a></li>
  </ul></li>
  <li><a href="#going-through-an-iteration" id="toc-going-through-an-iteration" class="nav-link" data-scroll-target="#going-through-an-iteration">Going through an Iteration</a>
  <ul class="collapse">
  <li><a href="#comparing-algorithms" id="toc-comparing-algorithms" class="nav-link" data-scroll-target="#comparing-algorithms">Comparing Algorithms</a></li>
  </ul></li>
  <li><a href="#similarities-to-reinforcement-learning" id="toc-similarities-to-reinforcement-learning" class="nav-link" data-scroll-target="#similarities-to-reinforcement-learning">Similarities to Reinforcement Learning</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Ultimate Guide to CFR</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="ultimate-guide-to-cfr" class="level1">
<h1>Ultimate Guide to CFR</h1>
<p>As we think about solving larger games, we start to look at iterative algorithms.</p>
<p>The most popular method for iteratively solving poker games is the Counterfactual Regret Minimization (CFR) algorithm. CFR is an iterative algorithm developed in 2007 at the University of Alberta that converges to Nash equilibrium in two player zero-sum games.</p>
<p>What is a counterfactual? Here’s an example:</p>
<p><strong>Actual event:</strong> I didn’t bring an umbrella, and I got wet in the rain</p>
<p><strong>Counterfactual event:</strong> If I had brought an umbrella, I wouldn’t have gotten wet</p>
<section id="tldr-cfr-explanation" class="level2">
<h2 class="anchored" data-anchor-id="tldr-cfr-explanation">TLDR CFR Explanation</h2>
<p>(But still slightly long)</p>
<p>CFR is a self play algorithm that learns by playing against itself repeatedly. It starts play with a uniform random strategy (each action at each decision point is equally likely) and iterates on these strategies to nudge closer to the game theory optimal Nash equilibrium strategy as the self play continues. The Nash equilibrium strategy is a “defensive” strategy that can’t be beaten, but also doesn’t take advantage of opponents. The counterfactual part comes from computing values based on assuming that our opponent plays to certain game states.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../assets/section4/cfr/infoset2.png" title="Kuhn Poker Tree from Alberta" class="img-fluid figure-img"></p>
<figcaption>Kuhn Poker Tree from Alberta</figcaption>
</figure>
</div>
<p>At each information set in the game tree, the algorithm keeps a counter of regret values for each possible action. The regret means how much better the agent would have done if it had always played that action rather than the actual strategy that could be a mixture of actions. Positive regret means we should have taken that action more and negative regret means we would have done better by not taking that action.</p>
<p>The values computed with the regret are called counterfactual values, which are the value of playing an action at a certain game state weighted by the probability (counterfactual assumption) of the other agent playing to that game state.</p>
<p>For example, if the agent was playing a game in which it had 5 action options at a certain game state and Action 1 had a value of 3 while the game state average over all 5 actions was 1, then the regret would be 3-1 = 2. This means that Action 1 was better than average and we should favor taking that action more.</p>
<p>The CFR algorithm updates the strategy after each iteration to play in proportion to the regrets, meaning that if an action did well in the past, the agent would be more likely to play it in the future.</p>
<p>The final Nash equilibrium strategy is the average strategy over each iteration. This strategy cannot lose in expectation and is considered optimal since it’s theoretically robust and neither player would have incentive to change strategies if both playing an equilibrium. This is what we mean when we say “solve” a poker game.</p>
<p>Michael Johanson, one of the authors on the original paper, gave his intuitive explanation of CFR in a <a href="https://www.quora.com/What-is-an-intuitive-explanation-of-counterfactual-regret-minimization">post on Quora</a>.</p>
<section id="regret-and-strategies" class="level3">
<h3 class="anchored" data-anchor-id="regret-and-strategies">Regret and Strategies</h3>
<p>A strategy at an infoset is a probability distribution over each possible action.</p>
<p>Regret is a measure of how much each strategy at an infoset is preferred and is used as a way to update strategies.</p>
<p>For a given P1 strategy and P2 strategy, a player has regret when they take an action at an infoset that was not the highest-EV action at that infoset.</p>
<div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Regret Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p><img src="assets/basictree.png" class="img-fluid"></p>
<p>What is the regret for each action?</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Action</th>
<th>Regret</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td></td>
</tr>
<tr class="even">
<td>B</td>
<td></td>
</tr>
<tr class="odd">
<td>C</td>
<td></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="callout callout-style-simple callout-warning no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Solution
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<table class="caption-top table">
<thead>
<tr class="header">
<th>Action</th>
<th>Regret</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>4</td>
</tr>
<tr class="even">
<td>B</td>
<td>2</td>
</tr>
<tr class="odd">
<td>C</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Expected Value Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p><img src="assets/basictree.png" class="img-fluid"></p>
<p>If taking a uniform strategy at this node (i.e.&nbsp;<span class="math inline">\(\frac{1}{3}\)</span> for each action), then what is the expected value of the node?</p>
</div>
</div>
<div class="callout callout-style-simple callout-warning no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Solution
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><span class="math inline">\(\mathbb{E} = \frac{1}{3}*1 + \frac{1}{3}*3+\frac{1}{3}*5 = 0.33+1+1.67 = 3\)</span></p>
</div>
</div>
</div>
<div class="callout callout-style-simple callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Poker Regret Exercise
</div>
</div>
<div class="callout-body-container callout-body">
<p><img src="assets/basictree.png" class="img-fluid"></p>
<p>In poker games, the regret for each action is defined as the value for that action minus the expected value of the node. Give the regret values for each action under this definition.</p>
</div>
</div>
<div class="callout callout-style-simple callout-warning no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Solution
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<table class="caption-top table">
<thead>
<tr class="header">
<th>Action</th>
<th>Value</th>
<th>Poker Regret</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>1</td>
<td>-2</td>
</tr>
<tr class="even">
<td>B</td>
<td>3</td>
<td>0</td>
</tr>
<tr class="odd">
<td>C</td>
<td>5</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>At a node in a poker game, the player prefers actions with higher regrets by this definition.</p>
</div>
</div>
</div>
<p>Each infoset maintains a <code>strategy</code> and <code>regret</code> tabular counter for each action. These accumulate the sum of all strategies and the sum of all regrets.</p>
<p>In a game like Rock Paper Scissors, there is effectively only one infoset, so only one table for <code>strategy</code> over each action (Rock, Paper, Scissors) and one table for <code>regret</code> over each action (Rock, Paper, Scissors).</p>
<p>Regrets are linked to strategies through a policy called <em>regret matching</em>.</p>
</section>
<section id="regret-matching" class="level3">
<h3 class="anchored" data-anchor-id="regret-matching">Regret Matching</h3>
<div class="callout callout-style-simple callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-7-contents" aria-controls="callout-7" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
RPS Regret Details
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-7" class="callout-7-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>In general, we define regret as:</p>
<p><span class="math inline">\(\text{Regret} = u(\text{Alternative Strategy}) − u(\text{Current Strategy})\)</span></p>
<p>We prefer alternative actions with high regret and wish to minimize our overall regret.</p>
<p>We play Rock and opponent plays Paper <span class="math inline">\(\implies \text{u(rock,paper)} = -1\)</span></p>
<p><span class="math inline">\(\text{Regret(scissors)} = \text{u(scissors,paper)} - \text{u(rock,paper)} = 1-(-1) = 2\)</span></p>
<p><span class="math inline">\(\text{Regret(paper)} = \text{u(paper,paper)} - \text{u(rock,paper)} = 0-(-1) = 1\)</span></p>
<p><span class="math inline">\(\text{Regret(rock)} = \text{u(rock,paper)} - \text{u(rock,paper)} = -1-(-1) = 0\)</span></p>
<p>We play Scissors and opponent plays Paper <span class="math inline">\(\implies \text{u(scissors,paper)} = 1\)</span></p>
<p><span class="math inline">\(\text{Regret(scissors)} = \text{u(scissors,paper)} - \text{u(scissors,paper)} = 1-1 = 0\)</span></p>
<p><span class="math inline">\(\text{Regret(paper)} = \text{u(paper,paper)} - \text{u(scissors,paper)} = 0-1 = -1\)</span></p>
<p><span class="math inline">\(\text{Regret(rock)} = \text{u(rock,paper)} - \text{u(scissors,paper)} = -1-1 = -2\)</span></p>
<p>We play Paper and opponent plays Paper <span class="math inline">\(\implies \text{u(paper,paper)} = 0\)</span></p>
<p><span class="math inline">\(\text{Regret(scissors)} = \text{u(scissors,paper)} - \text{u(paper,paper)} = 1-0 = 1\)</span></p>
<p><span class="math inline">\(\text{Regret(paper)} = \text{u(paper,paper)} - \text{u(paper,paper)} = 0-0 = 0\)</span>$</p>
<p><span class="math inline">\(\text{Regret(rock)} = \text{u(rock,paper)} - \text{u(paper,paper)} = -1-0 = -1\)</span></p>
<p>To generalize:</p>
<ul>
<li>The action played always gets a regret of 0 since the “alternative” is really just that same action</li>
<li>When we play a tying action, the alternative losing action gets a regret of -1 and the alternative winning action gets a regret of +1</li>
<li>When we play a winning action, the alternative tying action gets a regret of -1 and the alternative losing action gets a regret of -2</li>
<li>When we play a losing action, the alternative winning action gets a regret of +2 and the alternative tying action gets a regret of +1</li>
</ul>
<p>After each play, we accumulate regrets for each of the 3 actions.</p>
</div>
</div>
</div>
<p>We decide our strategy probability distribution using regret matching, which means playing a strategy that normalizes over the <em>positive</em> accumulated regrets, i.e.&nbsp;playing in proportion to the positive regrets.</p>
<p>Example from <a href="https://www.ma.imperial.ac.uk/~dturaev/neller-lanctot.pdf">Marc Lanctot’s CFR Tutorial</a>:</p>
<ul>
<li><p>Game 1: Choose Rock and opponent chooses Paper</p>
<ul>
<li>Lose 1</li>
<li>Rock: Regret 0</li>
<li>Paper: Regret 1</li>
<li>Scissors: Regret 2</li>
</ul></li>
<li><p>Next Action: Proportional <span class="math display">\[
\begin{pmatrix}
\text{Rock} &amp; 0/3 = 0 \\
\text{Paper} &amp; 1/3 = 0.333 \\
\text{Scissors} &amp; 2/3 = 0.667
\end{pmatrix}
\]</span></p></li>
<li><p>Game 2: Choose Scissors (With probability <span class="math inline">\(2/3\)</span>) and opponent chooses Rock</p>
<ul>
<li>Lose 1</li>
<li>Rock: Regret 1</li>
<li>Paper: Regret 2</li>
<li>Scissors: Regret 0</li>
</ul></li>
<li><p>Cumulative regrets:</p>
<ul>
<li>Rock: 1</li>
<li>Paper: 3</li>
<li>Scissors: 2</li>
</ul></li>
<li><p>Next Action: Proportional <span class="math display">\[
\begin{pmatrix}
\text{Rock} &amp; 1/6 = 0167 \\
\text{Paper} &amp; 3/6 = 0.500 \\
\text{Scissors} &amp; 2/6 = 0.333
\end{pmatrix}
\]</span></p></li>
</ul>
<p>Regret matching definitions:</p>
<ul>
<li><span class="math inline">\(a\)</span> is actions</li>
<li><span class="math inline">\(\sigma\)</span> is strategy</li>
<li><span class="math inline">\(t\)</span> is time</li>
<li><span class="math inline">\(i\)</span> is player</li>
<li><span class="math inline">\(R\)</span> is cumulative regret</li>
</ul>
<p><span class="math display">\[
\sigma_i^t(a) = \begin{cases}
\frac{\max(R_i^t(a), 0)}{\sum_{a' \in A} \max(R_i^t(a'), 0)} &amp; \text{if } \sum_{a' \in A} \max(R_i^t(a'), 0) &gt; 0 \\
\frac{1}{|A|} &amp; \text{otherwise}
\end{cases}
\]</span></p>
<p>This is showing that we take the cumulative regret for an action divided by the cumulative regrets for all actions (normalizing) and then play that strategy for this action on the next iteration.</p>
<p>If all cumulative regrets are <span class="math inline">\(\leq 0\)</span> then we use the uniform distribution.</p>
<p>If cumulative regrets are positive, but are are <span class="math inline">\(&lt;0\)</span> for a specific action, then we use <span class="math inline">\(0\)</span> for that action.</p>
<p>In code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_strategy(<span class="va">self</span>):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">#First find the normalizing sum</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        normalizing_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> a <span class="kw">in</span> <span class="bu">range</span>(NUM_ACTIONS):</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.regret_sum[a] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.strategy[a] <span class="op">=</span> <span class="va">self</span>.regret_sum[a]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.strategy[a] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            normalizing_sum <span class="op">+=</span> <span class="va">self</span>.strategy[a]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Then normalize each action</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> a <span class="kw">in</span> <span class="bu">range</span>(NUM_ACTIONS):</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> normalizing_sum <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.strategy[a] <span class="op">/=</span> normalizing_sum</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.strategy[a] <span class="op">=</span> <span class="fl">1.0</span><span class="op">/</span>NUM_ACTIONS</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.strategy_sum[a] <span class="op">+=</span> <span class="va">self</span>.strategy[a]</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.strategy</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>After using regret matching and after many iterations, we can minimize expected regret by using the <em>average</em> strategy at the end, which is the strategy that converges to equilibrium.</p>
<p>If two players were training against each other using regret matching, they would converge to the Nash Equilibrium of <span class="math inline">\(1/3\)</span> for each action using the average strategy in Rock Paper Scissors.</p>
</section>
<section id="rps-regret-matching-experiment" class="level3">
<h3 class="anchored" data-anchor-id="rps-regret-matching-experiment">RPS Regret Matching Experiment</h3>
<p>Here we show that regret matching converges only using the average strategy over 10,000 iterations:</p>
<p><img src="assets/rps_avg.png" class="img-fluid"></p>
<p>The bottom shows both players converging to <span class="math inline">\(1/3\)</span>, while the top shows Player 1’s volatile current strategies that are cycling around.</p>
<p>Suppose that your opponent Player 2 is playing 40% Rock, 30% Paper, and 30% Scissors. Here is a regret matching 10,000 game experiment. It shows that it takes around 1,600 games before Player 1 plays only Paper (this will vary).</p>
<p><img src="assets/rps_rm.png" class="img-fluid"></p>
<p>We see that if there is a fixed player, regret matching converges to the best strategy.</p>
<p>But what if your opponent is not using a fixed strategy? We’ll talk about that soon.</p>
</section>
<section id="iterating-through-the-tree" class="level3">
<h3 class="anchored" data-anchor-id="iterating-through-the-tree">Iterating through the Tree</h3>
<p>The core feature of the iterative algorithms is self-play by traversing the game tree over all <strong>infosets</strong> and tracking the strategies and regrets at each.</p>
<p>From above, we know how to find the strategy and regret in the simple Rock Paper Scissors environment.</p>
<p>In poker:</p>
<ul>
<li><p>Strategies are determined the same as above, through regret matching from the previous <code>regret</code> values at the specific information set for each action</p></li>
<li><p>CFR definitions:</p>
<ul>
<li><span class="math inline">\(a\)</span> is actions</li>
<li><span class="math inline">\(I\)</span> is infoset</li>
<li><span class="math inline">\(\sigma\)</span> is strategy</li>
<li><span class="math inline">\(t\)</span> is time</li>
<li><span class="math inline">\(i\)</span> is player</li>
<li><span class="math inline">\(R\)</span> is cumulative regret</li>
<li><span class="math inline">\(z\)</span> is a terminal node</li>
<li><span class="math inline">\(u\)</span> is utility (payoffs)</li>
<li><span class="math inline">\(p\)</span> is the current player who plays at this node</li>
<li><span class="math inline">\(-p\)</span> is the the opponent player and chance</li>
<li><span class="math inline">\(v\)</span> is counterfactual value</li>
</ul></li>
<li><p>Counterfactual values are effectively the value of an information set. They are weighted by the probability of opponent and chance playing to this node (in other words, the probability of playing to this node if this player tried to do so).</p>
<ul>
<li><p>Counterfactual value: <span class="math inline">\(v^\sigma (I) = \sum_{z\in Z_I} \pi^{\sigma}_{-p}(z[I])\pi^{\sigma}(z[I] \rightarrow z)u_p(z)\)</span></p></li>
<li><p><span class="math inline">\(\sum_{z\in Z_I}\)</span> is summing over all terminal histories reachable from this node</p></li>
<li><p><span class="math inline">\(\pi^{\sigma}_{-p}(z[I])\)</span> is the probability of opponents and chance reaching this node</p></li>
<li><p><span class="math inline">\(\pi^{\sigma}(z[I] \rightarrow z)\)</span> is the probability of playing from this node to terminal history <span class="math inline">\(z\)</span>, i.e.&nbsp;the weight component of the expected value</p></li>
<li><p><span class="math inline">\(u_p(z)\)</span> is the utility at terminal history <span class="math inline">\(z\)</span>, i.e.&nbsp;the value component of the expected value</p></li>
</ul></li>
<li><p>Instantaneous regrets are based on action values compared to infoset EV. Each action EV then adds to its <code>regret</code> counter:</p>
<ul>
<li><span class="math inline">\(r^t(I,a) = v^{\sigma^t}(I,a) - v^{\sigma^t}(I)\)</span></li>
</ul></li>
<li><p>Cumulative (counterfactual) regrets are the sum of the individual regrets:</p>
<ul>
<li><span class="math inline">\(R^T(I,a) = \sum_{t=1}^T r^t(I,a)\)</span></li>
</ul></li>
</ul>
</section>
<section id="alternativesupdates-to-original-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="alternativesupdates-to-original-algorithm">Alternatives/Updates to Original Algorithm</h3>
<ul>
<li><p>CFR+ variation such that regrets can’t be <span class="math inline">\(\leq 0\)</span></p></li>
<li><p>Linear CFR such that regrets are weighted by their recency</p></li>
<li><p>Sampling</p>
<ul>
<li>External: Sample chance and opponent nodes</li>
<li>Chance: Sample chance only</li>
<li>Outcome: Sample outcomes</li>
</ul></li>
</ul>
<p>The Counterfactual Regret Minimization (CFR) algorithm was first published in a 2007 paper from the University of Alberta by Martin Zinkevich et al.&nbsp;called “<a href="https://poker.cs.ualberta.ca/publications/NIPS07-cfr.pdf">Regret Minimization in Games with Incomplete Information</a>”. Counterfactual means “relating to or expressing what has not happened or is not the case”.</p>
</section>
</section>
<section id="the-algorithm" class="level2">
<h2 class="anchored" data-anchor-id="the-algorithm">The Algorithm</h2>
<p>Due to the constraints of solving imperfect information games with MCTS and the memory limits of solving games with linear programs, CFR was developed as a novel solution. CFR also benefits from being computationally cheap and doesn’t require parameter tuning. It is an iterative Nash equilibrium approximation method that works through the process of repeated self-play between two regret minimizing agents.</p>
<p>CFR is an extension of regret minimization into sequential games, where players play a sequence of actions to reach a terminal game state. Instead of storing and minimizing regret for the exponential number of strategies, CFR stores and minimizes a regret for each information set and its actions, which can be used to form an upper bound on the regret for any deterministic strategy. This means that we must also consider the probabilities of reaching each information set given the players’ strategies, as well as passing forward game state information and probabilities of player actions, and passing backward utility information through the game information states. The algorithm stores a strategy and regret value for each action at each node, such that the space requirement is on the order O(|I|), where |I| is the number of information sets in the game.</p>
<p>CFR is an offline self-play algorithm, as it learns to play by repeatedly playing against itself. It begins with a strategy that is completely uniformly random and adjusts the strategy each iteration using regret matching such that the strategy at each node is proportional to the regrets for each action. The regrets are, as explained previously, measures of how the current strategy would have performed compared to a fixed strategy of always taking one particular action. Positive regret means that we would have done better by taking that action more often and negative regret means that we would have done better by not taking that action at all. The average strategy is then shown to approach a Nash equilibrium in the long run.</p>
<p>In the vanilla CFR algorithm, each iteration involves passing through every node in the extensive form of the game. Each pass evaluates strategies for both players by using regret matching, based on the prior cumulative regrets at each player’s information sets. Before looking at the CFR equations, we will refresh some definitions that were given in previous sections here when they are relevant to the forthcoming equations.</p>
<p>Let A denote the set of all game actions. We refer to a strategy profile that excludes player i’s strategy as sigma_(-i). A history h is a sequence of actions, including chance outcomes, starting from the root of the game. Let pi^(sigma)(h) be the reach probability of game history h with strategy profile sigma and pi^sigma(h,z) be the reach probability that begins at h and ends at z.</p>
<p>Let Z denote the set of all terminal game histories and then we have h ⊏ z for z ∈ Z is a nonterminal game history. Let u_i(z) denote the utility to player i of terminal history z.</p>
<p>We can now define the counterfactual value at nonterminal history h as follows: v_i(sigma, h) = sum (z in Z),h ⊏ z of pi^sigma_(-i) * pi^sigma(h,z) * u_i(z)</p>
<p>This is the expected utility to player i of reaching nonterminal history h and taking action a under the counterfactual assumption that player i takes actions to do so, but otherwise player i and all other players follow the strategy profile sigma.</p>
<p>The counterfactual value takes a player’s strategy and history and returns a value that is the product of the reach probability of the opponent (and chance) to arrive to that history and the expected value of the player for all possible terminal histories from that point. This is counterfactual because we ignore the probabilities that factually came into player i’s play to reach position h, which means that he is not biasing his future strategy with his current strategy. This weights the regrets by how often nature (factors outside the player’s control, including chance and opponents) reach this information state. This is intuitive because states that are more frequently played to by opponents are more important to play profitably.</p>
<p>An information set is a group of histories that a player cannot distinguish between. Let I denote an information set and let A(I) denote the set of legal actions for information set I. Let sigma_(I–&gt;a) denote a profile equivalent to sigma, except that action a is always chosen at information set I. The counterfactual regret of not taking action a at history h is defined as:</p>
<p>r(h,a) = v_i(sigma_(i–&gt;a),h) - v_i(sigma, h)</p>
<p>This is the difference between the value when always selecting action a at the history node and the value of the history node itself (which will be defined in more detail shortly).</p>
<p>Let pi^sigma(I) be the probability of reaching information set I through all possible game histories in I. Therefore we have that pi^sigma(I) = sum h∈I pi^sigma(h). The counterfactual reach probability of information state I, p^sigma_(-i)(I), is the probability of reaching I with strategy profile sigma except that, we treat current player I actions to reach the state as having probability 1.</p>
<p>The counterfactual regret of not taking action a at information set I is: r(I,a) = sum h∈I r(h,a)</p>
<p>This calculation simply includes all histories in the information set.</p>
<p>Let t and T denote time steps, where t is with respect to each fixed information set and is incremented with each visit to an information set. A strategy sigma^t_i for player i maps each player i information set I_i and legal player i action a∈A(I_i) to the probability that the player will choose a in I_i at time t. All player strategies together at time t form a strategy profile sigma^t, to be detailed shortly.</p>
<p>If we define r^t_i(I,a) as the regret when players use sigma_t of not taking action a at information set I belonging to player i, then we can define the cumulative counterfactual regret as follows, which is the summation over all time steps:</p>
<p>R^T_i(I,a) = sum t=1 to T r^t_i(I,a)</p>
<p>In recent years, researchers have redefined the counterfactual value in terms of information sets. This formulation shows the counterfactual value for a particular information set and action, given a player and his strategy:</p>
<p>v^sigma_i(I,a) = sum h∈I sum z∈Z: h⊏z u_i(z)pi<sup>sigma_(-i)(z)pi</sup>sigma:I–&gt;a _i(h,z)</p>
<p>We see that this is similar to the first equation for the counterfactual value, but has some differences. Because we are now calculating the value for an information set, we must sum over all of the relevant histories. The inner summation adds all possible leaf nodes that can be reached from the current history (same as the original one) and the outer summation adds all histories that are part of the current information set.</p>
<p>From left to right, the three terms on the right hand side represent the main player’s utility at the leaf node z, the opponent and chance combined reach probability for the leaf node z, and the reach probability of the main player to go from the current history to the leaf node z, while always taking action a. The differences between this formulation and that of the original equation will be reconciled with the next equation.</p>
<p>The counterfactual regret of player i for action a at information set I can be written as follows:</p>
<p>R^T_i(I,a) = sum t=1,T v<sup>sigma</sup>t _i(I,a) - sum t=1,T sum a’∈A v<sup>sigma</sup>T _i (I,a’)sigma^t_i(a’\|I)</p>
<p>This formulation combines the three equations, where one had introduced the cumulative summation, one added all histories in the information set, and one defined the counterfactual regret difference equation. The first part of the difference in the counterfactual regret equation computes this value for the given a value, while the second part computes the expected value of all other a value options at the information set.</p>
<p>The inner summation of this part of the equation is over all non-a strategies and the outer summation is over all times. The first term in the summations computes the counterfactual value for each non-a strategy and the second term multiplies the counterfactual value by the player’s probability of playing that particular strategy at the given information set.</p>
<p>We can show the regret-matching algorithm by first defining the nonnegative counterfactual regret as R^T,+ _i (I,a) = max(R^T _i(I,a),0). Now we can use the cumulative regrets to obtain the strategy decision for the next iteration using regret matching:</p>
<p>Case 1 when sum a’∈A R^(t-1) _i (I,a’))^+ &gt; 0 then sigma^t _i(a\|I) = (R^(t-1) _i (i,a))^+ / (sum a’∈A R^(t-1) _i (I,a’))^+)</p>
<p>Case 2 otherwise then sigma^t _i(a\|I) = 1/\| A \|</p>
<p>This regret matching formula calculates the action probabilities for each action at each information set in proportion to the positive cumulative regrets. First we check to see if the cumulative regrets at the previous time step are positive. If not, the strategy is set to be uniformly random, determined by the number of available actions. If it is, then the strategy is the ratio of the cumulative regret of the defined action over the sum of the cumulative regrets of all other actions.</p>
<p>The CFR algorithm works by taking these action probabilities and then producing the next state in the game and computing the utilities of each action recursively. Regrets are computed from the returned values and the value of playing to the current node is then computed and returned. Regrets are updated at the end of each iteration.</p>
</section>
<section id="regret-bounds-and-convergence-rates" class="level2">
<h2 class="anchored" data-anchor-id="regret-bounds-and-convergence-rates">Regret Bounds and Convergence Rates</h2>
<p>CFR has been shown to eliminate all dominated strategies from its final average strategy solution.</p>
<p>By following regret matching, the following bound, showing that the counterfactual regret at each information set grows sublinearly with the number of iterations, is guaranteed, given that delta = maximum difference in leaf node utilities (|u_i(z) − u_i(z’)| ≤ delta for all i ∈ N and z,z’ ∈ Z), A = number of actions, T = iteration number.</p>
<p>R^T _i_infoset(I,a) &lt;= delta * sqrt(\| A \| * T)</p>
<p>With a specific set of strategy profiles, we can define a player’s overall regret as: R^T <em>i_overall = max sigma_i ∈ sum i (sum t=1 to T u_i(sigma_i, sigma^T </em>-i)) - sum t=1 to T u_i(sigma)</p>
<p>This is the amount of extra utility that player i could have achieved in expectation if he had chosen the best fixed strategy in hindsight. Assuming perfect recall, this can be bounded by the per information set counterfactual regrets of CFR:</p>
<p>R^T _i_overall &lt;= sum I∈I_i max a∈A R^T _i_infoset(I,a) &lt;= \|I_i\| * delta * sqrt(\|A\|*T)</p>
<p>The fact that minimizing regret at each information set results in minimizing overall regret is a key insight for why CFR works and since CFR indeed achieves sublinear regret, this means that it is a regret minimizing algorithm.</p>
<p>In a two-player zero-sum game with perfect recall, for R^t _i ≤ ε for all players, then the average strategy profile is known to be a 2ε Nash equilibrium. We can therefore use the regret minimizing properties of CFR to solve games like poker by computing average strategies as follows:</p>
<p>sigmahat(a|I) = [sum t=1,T (sum h∈I pi<sup>sigma</sup>t _i (h)) * sigma^t(a|I)] / [sum t=1,T (sum h∈I pi<sup>sigma</sup>t _i (h)))]</p>
<p>where sum t=1,T (sum h∈I pi<sup>sigma</sup>t _i (h))) is each player’s contribution to the probability of reaching a history in information set I, and is therefore the weighting term on sigma^T _i.</p>
<p>The strategies are combined such that they select an action at an information set in proportion to that strategy’s probability of playing to reach that information set. We run the CFR algorithm for a sufficient number of iterations in order to reduce the ε sufficiently.</p>
<p>In the end, it is the average strategy profile that converges to Nash equilibrium. The best available guarantees for CFR require ~1/ε^2 iterations over the game tree to reach an ε-equilibrium, that is, strategies for players such that no player can be exploited by more than ε by any strategy.</p>
<p>The gradient-based algorithms, which match the optimal number of iterations needed, require only ~1/ε or ~log (1/ε) iterations. However, due to effective CFR sampling methods, quick approximate iterations can be used such that sampling CFR is still the preferred solution method.</p>
<!-- Counterfactual value of player i taking action a at information set I: 
$$ v_i^\sigma{}(I,a) = \sum{\sum{u_i(z)\pi_{-i}^\sigma{}(z)pi_i^{\sigma{}:I->a}(h,z)} $$ -->
<!-- In words, this is the expected utility to player i of reaching information set I and taking action a, under the counterfactual assumption that player i takes actions to do so, but otherwise player i and all other players follow the strategy profile $$ \sigma{} $$ -->
<section id="why-average-strategy" class="level3">
<h3 class="anchored" data-anchor-id="why-average-strategy">Why average strategy?</h3>
<p>A good intuitive way to think about why at the end of running CFR, the average strategy is the Nash equilibrium rather than the final strategy being Nash equilibrium comes from looking at rock paper scissors.</p>
<p>Suppose that our opponent is playing Rock too much, then CFR moves us towards playing 100% paper (moving towards the best response to their strategy, i.e.&nbsp;the goal of regret minimization). The current strategy can be mixed (and it starts off uniform random), but it gets updated to maximize exploiting opponents and tends to cycle between pure-ish strategies (assuming that we are playing against a real opponent and not using self-play).</p>
<p>So the algorithm moves us to 100% paper and then the opponent might move to 100% scissors and then we move to 100% rock, and so on! While the current strategy is making sharp bounces around the strategy space without stopping at equilibrium, the average strategy cycles in closer and closer to converging at equilibrium, which in rock paper scissors is playing each action a third of the time. Intuitively it makes sense that the average strategy would be more robust than just taking the final strategy, which could be at a strange point that clearly wouldn’t be an equilibrium.</p>
<p>That said, recent research teams have simply used the final strategy after many many iterations and have had good results, which saves a lot of memory and computation since all of the strategies throughout don’t need to be stored and averaged.</p>
<!-- 
### Definitions
Let A denote the set of all game actions. We refer to a strategy profile that excludes
player i’s strategy as $$\sigma_{-i}$$. A history $$h$$ is a sequence of actions, including chance outcomes, starting from the root of the game. Let $$\pi^\sigma(h)$$ be the reach probability of game history $h$ with strategy profile $$\sigma$$ and $$\pi^\sigma(h,z)$$ be the reach probability that begins at $$h$$ and ends at $$z$$. 

Let Z denote the set of all terminal game histories and then we have $$h \sqsubset z$$ for $$z \in Z$$ is a nonterminal game history. Let $$u_i(z)$$ denote the utility to player $$i$$ of terminal history $$z$$. 

We can now define the counterfactual value at nonterminal history $$h$$ as follows: 

$$ v_i(\sigma, h) \equiv \sum{u_i(z)\pi_{-i}^\sigma{}(z)pi_i^{\sigma{}:I->a}(h,z) $$ -->
</section>
<section id="vanilla-cfr" class="level3">
<h3 class="anchored" data-anchor-id="vanilla-cfr">Vanilla CFR</h3>
<p>Vanilla CFR is the default CFR method where each pass is a full iteration of the game tree. This has been used less ever since the Monte Carlo sampling CFR methods began from Marc Lanctot’s research. Although sampling means a larger number of iterations are needed to reach near equilibrium levels, each iteration is generally much faster and overall calculation time is generally significantly reduced since regrets are updated very quickly, instead of only after every long iteration as is the case with vanilla CFR. Vanilla CFR works by passing forward probabilities and game states and passing back utility values and can solve games as large as about 10^12 game states.</p>
</section>
<section id="monte-carlo-cfr-mccfr" class="level3">
<h3 class="anchored" data-anchor-id="monte-carlo-cfr-mccfr">Monte Carlo CFR (MCCFR)</h3>
<p>In Monte Carlo CFR, some sampling method is used to sample to terminal state(s) of the game and then updates are applied only to the sample and not the full tree. Other than that, the updates occur the same way as they do in the standard algorithm.</p>
<p>The benefit of Monte Carlo CFR is that it uses sampling to make quicker updates to the game tree, even though these updates may be noisy, in practice they are much faster than the precise and slow updates of the vanilla implementation. Memory requirements remain the same as in vanilla CFR since the same information is being stored.</p>
<p>In practice, this means updating the counterfactual value equation with a 1/q(z) factor to define the probability of sampling a particular terminal history z. Also the summation is defined only for the information set when z is in the sample and passes through the information set I on the way to z. It can be shown that the sampled counterfactual values are equivalent in expectation to the vanilla version, meaning that MCCFR also will be guaranteed to converge to a Nash equilibrium.</p>
<p>An issue arises with sampling that when taking the average strategy, all nodes may not have been sampled equal times. This can be addressed in two ways, each of which has its own disadvantages: 1. Optimistic averaging: A counter is placed at each node and updates are weighted by the last time they were seen at this node, which requires<br>
extra memory, is only an approximation, and requires a final iteration<br>
since some counters will be outdated.<br>
2. Stochastically weighted averaging: Increase the magnitude of each<br>
strategy by sampling the strategy profile probability. This is unbiased, but results in large variance.</p>
<p>We touch on two of the most common sampling methods below, called external sampling and chance sampling. Outcome sampling is another method that is the most extreme possible sampling – it samples one action down the whole tree.</p>
<section id="external-sampling" class="level4">
<h4 class="anchored" data-anchor-id="external-sampling">External Sampling</h4>
<p>External Sampling entails sampling the actions of the opponent and of chance only. This means that these samples are based on how likely the opponent’s plays are to occur, which is sensible, since then regret values corresponding to these plays are updated faster. We go into this in more detail in Section 4.4 regarding Deep CFR, but provide code here in Python for Kuhn Poker and Leduc Poker.</p>
<p>Kuhn External CFR code:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Node:</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, num_actions):</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.regret_sum <span class="op">=</span> np.zeros(num_actions)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.strategy <span class="op">=</span> np.zeros(num_actions)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.strategy_sum <span class="op">=</span> np.zeros(num_actions)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.num_actions <span class="op">=</span> num_actions</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_strategy(<span class="va">self</span>):</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        normalizing_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> a <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.num_actions):</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.regret_sum[a] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.strategy[a] <span class="op">=</span> <span class="va">self</span>.regret_sum[a]</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.strategy[a] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>            normalizing_sum <span class="op">+=</span> <span class="va">self</span>.strategy[a]</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> a <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.num_actions):</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> normalizing_sum <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.strategy[a] <span class="op">/=</span> normalizing_sum</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.strategy[a] <span class="op">=</span> <span class="fl">1.0</span><span class="op">/</span><span class="va">self</span>.num_actions</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.strategy</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_average_strategy(<span class="va">self</span>):</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        avg_strategy <span class="op">=</span> np.zeros(<span class="va">self</span>.num_actions)</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>        normalizing_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> a <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.num_actions):</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>            normalizing_sum <span class="op">+=</span> <span class="va">self</span>.strategy_sum[a]</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> a <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.num_actions):</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> normalizing_sum <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>                avg_strategy[a] <span class="op">=</span> <span class="va">self</span>.strategy_sum[a] <span class="op">/</span> normalizing_sum</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>                avg_strategy[a] <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> <span class="va">self</span>.num_actions</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> avg_strategy</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> KuhnCFR:</span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, iterations, decksize):</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nbets <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.iterations <span class="op">=</span> iterations</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.decksize <span class="op">=</span> decksize</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cards <span class="op">=</span> np.arange(decksize)</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bet_options <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nodes <span class="op">=</span> {}</span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> cfr_iterations_external(<span class="va">self</span>):</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>        util <span class="op">=</span> np.zeros(<span class="dv">2</span>)</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="va">self</span>.iterations <span class="op">+</span> <span class="dv">1</span>): </span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>                random.shuffle(<span class="va">self</span>.cards)</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>                util[i] <span class="op">+=</span> <span class="va">self</span>.external_cfr(<span class="va">self</span>.cards[:<span class="dv">2</span>], [], <span class="dv">2</span>, <span class="dv">0</span>, i, t)</span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(i, util[i])</span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">'Average game value: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(util[<span class="dv">0</span>]<span class="op">/</span>(<span class="va">self</span>.iterations)))</span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">sorted</span>(<span class="va">self</span>.nodes):</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(i, <span class="va">self</span>.nodes[i].get_average_strategy())</span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> external_cfr(<span class="va">self</span>, cards, history, pot, nodes_touched, traversing_player, t):</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">'THIS IS ITERATION'</span>, t)</span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(cards, history, pot)</span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>        plays <span class="op">=</span> <span class="bu">len</span>(history)</span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>        acting_player <span class="op">=</span> plays <span class="op">%</span> <span class="dv">2</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>        opponent_player <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> acting_player</span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> plays <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> history[<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> history[<span class="op">-</span><span class="dv">2</span>] <span class="op">==</span> <span class="dv">1</span>: <span class="co">#bet fold</span></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> acting_player <span class="op">==</span> traversing_player:</span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (history[<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> history[<span class="op">-</span><span class="dv">2</span>] <span class="op">==</span> <span class="dv">0</span>) <span class="kw">or</span> (history[<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> history[<span class="op">-</span><span class="dv">2</span>] <span class="op">==</span> <span class="dv">1</span>): <span class="co">#check check or bet call, go to showdown</span></span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> acting_player <span class="op">==</span> traversing_player:</span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> cards[acting_player] <span class="op">&gt;</span> cards[opponent_player]:</span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">return</span> pot<span class="op">/</span><span class="dv">2</span> <span class="co">#profit</span></span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">else</span>:</span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">return</span> <span class="op">-</span>pot<span class="op">/</span><span class="dv">2</span></span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> cards[acting_player] <span class="op">&gt;</span> cards[opponent_player]:</span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">return</span> <span class="op">-</span>pot<span class="op">/</span><span class="dv">2</span></span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">else</span>:</span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">return</span> pot<span class="op">/</span><span class="dv">2</span></span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a>        infoset <span class="op">=</span> <span class="bu">str</span>(cards[acting_player]) <span class="op">+</span> <span class="bu">str</span>(history)</span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> infoset <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.nodes:</span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.nodes[infoset] <span class="op">=</span> Node(<span class="va">self</span>.bet_options)</span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a>        nodes_touched <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> acting_player <span class="op">==</span> traversing_player:</span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a>            util <span class="op">=</span> np.zeros(<span class="va">self</span>.bet_options) <span class="co">#2 actions</span></span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a>            node_util <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a>            strategy <span class="op">=</span> <span class="va">self</span>.nodes[infoset].get_strategy()</span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> a <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.bet_options):</span>
<span id="cb2-97"><a href="#cb2-97" aria-hidden="true" tabindex="-1"></a>                next_history <span class="op">=</span> history <span class="op">+</span> [a]</span>
<span id="cb2-98"><a href="#cb2-98" aria-hidden="true" tabindex="-1"></a>                pot <span class="op">+=</span> a</span>
<span id="cb2-99"><a href="#cb2-99" aria-hidden="true" tabindex="-1"></a>                util[a] <span class="op">=</span> <span class="va">self</span>.external_cfr(cards, next_history, pot, nodes_touched, traversing_player, t)</span>
<span id="cb2-100"><a href="#cb2-100" aria-hidden="true" tabindex="-1"></a>                node_util <span class="op">+=</span> strategy[a] <span class="op">*</span> util[a]</span>
<span id="cb2-101"><a href="#cb2-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-102"><a href="#cb2-102" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> a <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.bet_options):</span>
<span id="cb2-103"><a href="#cb2-103" aria-hidden="true" tabindex="-1"></a>                regret <span class="op">=</span> util[a] <span class="op">-</span> node_util</span>
<span id="cb2-104"><a href="#cb2-104" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.nodes[infoset].regret_sum[a] <span class="op">+=</span> regret</span>
<span id="cb2-105"><a href="#cb2-105" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> node_util</span>
<span id="cb2-106"><a href="#cb2-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-107"><a href="#cb2-107" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: <span class="co">#acting_player != traversing_player</span></span>
<span id="cb2-108"><a href="#cb2-108" aria-hidden="true" tabindex="-1"></a>            strategy <span class="op">=</span> <span class="va">self</span>.nodes[infoset].get_strategy()</span>
<span id="cb2-109"><a href="#cb2-109" aria-hidden="true" tabindex="-1"></a>            util <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-110"><a href="#cb2-110" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> random.random() <span class="op">&lt;</span> strategy[<span class="dv">0</span>]:</span>
<span id="cb2-111"><a href="#cb2-111" aria-hidden="true" tabindex="-1"></a>                next_history <span class="op">=</span> history <span class="op">+</span> [<span class="dv">0</span>]</span>
<span id="cb2-112"><a href="#cb2-112" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>: </span>
<span id="cb2-113"><a href="#cb2-113" aria-hidden="true" tabindex="-1"></a>                next_history <span class="op">=</span> history <span class="op">+</span> [<span class="dv">1</span>]</span>
<span id="cb2-114"><a href="#cb2-114" aria-hidden="true" tabindex="-1"></a>                pot <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-115"><a href="#cb2-115" aria-hidden="true" tabindex="-1"></a>            util <span class="op">=</span> <span class="va">self</span>.external_cfr(cards, next_history, pot, nodes_touched, traversing_player, t)</span>
<span id="cb2-116"><a href="#cb2-116" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> a <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.bet_options):</span>
<span id="cb2-117"><a href="#cb2-117" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.nodes[infoset].strategy_sum[a] <span class="op">+=</span> strategy[a]</span>
<span id="cb2-118"><a href="#cb2-118" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> util</span>
<span id="cb2-119"><a href="#cb2-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-120"><a href="#cb2-120" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb2-121"><a href="#cb2-121" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> KuhnCFR(<span class="dv">100000</span>, <span class="dv">10</span>)</span>
<span id="cb2-122"><a href="#cb2-122" aria-hidden="true" tabindex="-1"></a>    k.cfr_iterations_external()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The Kuhn Poker External Sampling CFR code uses two main classes, the Node class to track information sets of the game and the KuhnCFR class to run the actual CFR function. The Node class stores the relevant variables (regret_sum, strategy, strategy_sum, and num_actions). The get_strategy function is called throughout CFR to compute the strategy using regret matching, while the get_average_strategy function is called only at the end of all of the iterations to produce the final Nash equilibrium strategy.</p>
<p>In the main KuhnCFR class, the cfr_iterations_external function runs the main parts of the algorithm, with a loop for the number of iterations and a loop for each player, after which the CFR function is called and the output is summed in a utility value for each player to compute the game value by the end of the game. The CFR function itself first determines who the acting player is, then does various checks to see whether the game state is terminal, and the value with respect to the traversing player is returned (passed up). The game is terminal either after bet fold (no showdown) or check check (showdown) or bet call (showdown).</p>
<p>In the case where the state was not terminal, we set the information set, which is defined as the acting player’s cards concatenated with the history. A new Node is created if the information set was not seen before.</p>
<p>The rest of the algorithm is split into two parts, depending on if the acting player is the traversing player or not. If it is the traversing player, then we compute the strategy using the get_strategy() function based on regret matching with the accumulated regrets at the node, then cycle through every possible bet option and recursively call the cfr function using the updated history and pot size based on the bet option taking place. This is then added to the accumulating node_util variable that computes the average value of the node (each action’s utility weighted by how often that action is played). Once again, we iterate through all of the bet options and now compute the regrets, which are derived as the utility of the action minus the node utility. These regrets are then added to the regret_sum of the node for that particular action. Finally, the node utility is returned.</p>
<p>If the acting player is not the traversing player, then we once again find the strategy using the get_strategy() function and now we sample a single action from that strategy. In Kuhn Poker this is simple because there are only two possible actions, so we just generate a random number from 0 to 1 and if it’s less than the probability of passing, then we take the pass action, otherwise we take the bet action and add 1 to the pot. We recursively call the CFR function using the updated next_history and pot and then update the strategy_sum for each strategy at this information set. Finally, we return the utility of the sampled action.</p>
<p>Leduc External CFR code:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Node:</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, bet_options):</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.num_actions <span class="op">=</span> <span class="bu">len</span>(bet_options)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.regret_sum <span class="op">=</span> defaultdict(<span class="bu">int</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.strategy <span class="op">=</span> defaultdict(<span class="bu">int</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.strategy_sum <span class="op">=</span> defaultdict(<span class="bu">int</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bet_options <span class="op">=</span> bet_options</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_strategy(<span class="va">self</span>):</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        normalizing_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> a <span class="kw">in</span> <span class="va">self</span>.bet_options:</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.regret_sum[a] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.strategy[a] <span class="op">=</span> <span class="va">self</span>.regret_sum[a]</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.strategy[a] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>            normalizing_sum <span class="op">+=</span> <span class="va">self</span>.strategy[a]</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> a <span class="kw">in</span> <span class="va">self</span>.bet_options:</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> normalizing_sum <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.strategy[a] <span class="op">/=</span> normalizing_sum</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.strategy[a] <span class="op">=</span> <span class="fl">1.0</span><span class="op">/</span><span class="va">self</span>.num_actions</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.strategy</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_average_strategy(<span class="va">self</span>):</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        avg_strategy <span class="op">=</span> defaultdict(<span class="bu">int</span>)</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        normalizing_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> a <span class="kw">in</span> <span class="va">self</span>.bet_options:</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>            normalizing_sum <span class="op">+=</span> <span class="va">self</span>.strategy_sum[a]</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> a <span class="kw">in</span> <span class="va">self</span>.bet_options:</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> normalizing_sum <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>                avg_strategy[a] <span class="op">=</span> <span class="va">self</span>.strategy_sum[a] <span class="op">/</span> normalizing_sum</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>                avg_strategy[a] <span class="op">=</span> <span class="fl">1.0</span> <span class="op">/</span> <span class="va">self</span>.num_actions</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> avg_strategy</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> LeducCFR:</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, iterations, decksize, starting_stack):</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>        <span class="co">#self.nbets = 2</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.iterations <span class="op">=</span> iterations</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.decksize <span class="op">=</span> decksize</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.bet_options <span class="op">=</span> starting_stack</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.cards <span class="op">=</span> <span class="bu">sorted</span>(np.concatenate((np.arange(decksize),np.arange(decksize))))</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nodes <span class="op">=</span> {}</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> cfr_iterations_external(<span class="va">self</span>):</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>        util <span class="op">=</span> np.zeros(<span class="dv">2</span>)</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="va">self</span>.iterations <span class="op">+</span> <span class="dv">1</span>): </span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>):</span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>                    random.shuffle(<span class="va">self</span>.cards)</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>                    util[i] <span class="op">+=</span> <span class="va">self</span>.external_cfr(<span class="va">self</span>.cards[:<span class="dv">3</span>], [[], []], <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">0</span>, i, t)</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">'Average game value: </span><span class="sc">{}</span><span class="st">'</span>.<span class="bu">format</span>(util[<span class="dv">0</span>]<span class="op">/</span>(<span class="va">self</span>.iterations)))</span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> <span class="bu">open</span>(<span class="st">'leducnlstrat.txt'</span>, <span class="st">'w+'</span>) <span class="im">as</span> f:</span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">sorted</span>(<span class="va">self</span>.nodes):</span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a>                f.write(<span class="st">'</span><span class="sc">{}</span><span class="st">, </span><span class="sc">{}</span><span class="ch">\n</span><span class="st">'</span>.<span class="bu">format</span>(i, <span class="va">self</span>.nodes[i].get_average_strategy()))</span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(i, <span class="va">self</span>.nodes[i].get_average_strategy())</span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> winning_hand(<span class="va">self</span>, cards):</span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> cards[<span class="dv">0</span>] <span class="op">==</span> cards[<span class="dv">2</span>]:</span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> cards[<span class="dv">1</span>] <span class="op">==</span> cards[<span class="dv">2</span>]:</span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> cards[<span class="dv">0</span>] <span class="op">&gt;</span> cards[<span class="dv">1</span>]:</span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> cards[<span class="dv">1</span>] <span class="op">&gt;</span> cards[<span class="dv">0</span>]:</span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> cards[<span class="dv">1</span>] <span class="op">==</span> cards[<span class="dv">0</span>]:</span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> valid_bets(<span class="va">self</span>, history, rd, acting_player):</span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> acting_player <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a>            acting_stack <span class="op">=</span> <span class="bu">int</span>(<span class="dv">19</span> <span class="op">-</span> (np.<span class="bu">sum</span>(history[<span class="dv">0</span>][<span class="dv">0</span>::<span class="dv">2</span>]) <span class="op">+</span> np.<span class="bu">sum</span>(history[<span class="dv">1</span>][<span class="dv">0</span>::<span class="dv">2</span>])))</span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> acting_player <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-82"><a href="#cb3-82" aria-hidden="true" tabindex="-1"></a>            acting_stack <span class="op">=</span> <span class="bu">int</span>(<span class="dv">19</span> <span class="op">-</span> (np.<span class="bu">sum</span>(history[<span class="dv">0</span>][<span class="dv">1</span>::<span class="dv">2</span>]) <span class="op">+</span> np.<span class="bu">sum</span>(history[<span class="dv">1</span>][<span class="dv">1</span>::<span class="dv">2</span>])))</span>
<span id="cb3-83"><a href="#cb3-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-84"><a href="#cb3-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-85"><a href="#cb3-85" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print('VALID BETS CHECK HISTORY', history)</span></span>
<span id="cb3-86"><a href="#cb3-86" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print('VALID BETS CHECK ROUND', rd)</span></span>
<span id="cb3-87"><a href="#cb3-87" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print('VALID BETS CHECK ACTING STACK', acting_stack)</span></span>
<span id="cb3-88"><a href="#cb3-88" aria-hidden="true" tabindex="-1"></a>        curr_history <span class="op">=</span> history[rd]</span>
<span id="cb3-89"><a href="#cb3-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-90"><a href="#cb3-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-91"><a href="#cb3-91" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(history[rd]) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-92"><a href="#cb3-92" aria-hidden="true" tabindex="-1"></a>            <span class="co"># print('CASE LEN 0', [*np.arange(acting_stack+1)])</span></span>
<span id="cb3-93"><a href="#cb3-93" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> [<span class="op">*</span>np.arange(acting_stack<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb3-94"><a href="#cb3-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-95"><a href="#cb3-95" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="bu">len</span>(history[rd]) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-96"><a href="#cb3-96" aria-hidden="true" tabindex="-1"></a>            min_raise <span class="op">=</span> curr_history[<span class="dv">0</span>]<span class="op">*</span><span class="dv">2</span></span>
<span id="cb3-97"><a href="#cb3-97" aria-hidden="true" tabindex="-1"></a>            call_amount <span class="op">=</span> curr_history[<span class="dv">0</span>]</span>
<span id="cb3-98"><a href="#cb3-98" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> min_raise <span class="op">&gt;</span> acting_stack:</span>
<span id="cb3-99"><a href="#cb3-99" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> history[rd] <span class="op">==</span> [acting_stack]:</span>
<span id="cb3-100"><a href="#cb3-100" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># print('CASE LEN 1', [0, acting_stack])</span></span>
<span id="cb3-101"><a href="#cb3-101" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> [<span class="dv">0</span>, acting_stack]</span>
<span id="cb3-102"><a href="#cb3-102" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb3-103"><a href="#cb3-103" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># print('CASE LEN 1', [0, call_amount, acting_stack])</span></span>
<span id="cb3-104"><a href="#cb3-104" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> [<span class="dv">0</span>, call_amount, acting_stack]</span>
<span id="cb3-105"><a href="#cb3-105" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-106"><a href="#cb3-106" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> history[rd] <span class="op">==</span> [<span class="dv">0</span>]:</span>
<span id="cb3-107"><a href="#cb3-107" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># print('CASE LEN 1', [*np.arange(min_raise, acting_stack+1)])</span></span>
<span id="cb3-108"><a href="#cb3-108" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> [<span class="op">*</span>np.arange(min_raise, acting_stack<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb3-109"><a href="#cb3-109" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb3-110"><a href="#cb3-110" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># print('CASE LEN 1', [0, call_amount, *np.arange(min_raise, acting_stack+1)])</span></span>
<span id="cb3-111"><a href="#cb3-111" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> [<span class="dv">0</span>, call_amount, <span class="op">*</span>np.arange(min_raise, acting_stack<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb3-112"><a href="#cb3-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-113"><a href="#cb3-113" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="bu">len</span>(history[rd]) <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb3-114"><a href="#cb3-114" aria-hidden="true" tabindex="-1"></a>            min_raise <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>(curr_history[<span class="dv">1</span>] <span class="op">-</span> curr_history[<span class="dv">0</span>])</span>
<span id="cb3-115"><a href="#cb3-115" aria-hidden="true" tabindex="-1"></a>            call_amount <span class="op">=</span> curr_history[<span class="dv">1</span>] <span class="op">-</span> curr_history[<span class="dv">0</span>]</span>
<span id="cb3-116"><a href="#cb3-116" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> min_raise <span class="op">&gt;</span> acting_stack:</span>
<span id="cb3-117"><a href="#cb3-117" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> call_amount <span class="op">==</span> acting_stack:</span>
<span id="cb3-118"><a href="#cb3-118" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># print('CASE LEN 2', [0, acting_stack])</span></span>
<span id="cb3-119"><a href="#cb3-119" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> [<span class="dv">0</span>, acting_stack]</span>
<span id="cb3-120"><a href="#cb3-120" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb3-121"><a href="#cb3-121" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># print('CASE LEN 2', [0, call_amount, acting_stack])</span></span>
<span id="cb3-122"><a href="#cb3-122" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> [<span class="dv">0</span>, call_amount, acting_stack]</span>
<span id="cb3-123"><a href="#cb3-123" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-124"><a href="#cb3-124" aria-hidden="true" tabindex="-1"></a>                <span class="co"># print('CASE LEN 2', [0, call_amount, *np.arange(min_raise, acting_stack+1)])</span></span>
<span id="cb3-125"><a href="#cb3-125" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> [<span class="dv">0</span>, call_amount, <span class="op">*</span>np.arange(min_raise, acting_stack<span class="op">+</span><span class="dv">1</span>)]</span>
<span id="cb3-126"><a href="#cb3-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-127"><a href="#cb3-127" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="bu">len</span>(history[rd]) <span class="op">==</span> <span class="dv">3</span>:</span>
<span id="cb3-128"><a href="#cb3-128" aria-hidden="true" tabindex="-1"></a>            call_amount <span class="op">=</span> np.<span class="bu">abs</span>(curr_history[<span class="dv">1</span>] <span class="op">-</span> curr_history[<span class="dv">2</span>] <span class="op">-</span> curr_history[<span class="dv">0</span>])</span>
<span id="cb3-129"><a href="#cb3-129" aria-hidden="true" tabindex="-1"></a>            <span class="co"># print('CASE LEN 3', [0, call_amount])</span></span>
<span id="cb3-130"><a href="#cb3-130" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> [<span class="dv">0</span>, call_amount] <span class="co">#final bet (4 maximum per rd)</span></span>
<span id="cb3-131"><a href="#cb3-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-132"><a href="#cb3-132" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> external_cfr(<span class="va">self</span>, cards, history, rd, pot, nodes_touched, traversing_player, t):</span>
<span id="cb3-133"><a href="#cb3-133" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> t <span class="op">%</span> <span class="dv">1000</span> <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> t<span class="op">&gt;</span><span class="dv">0</span>:</span>
<span id="cb3-134"><a href="#cb3-134" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">'THIS IS ITERATION'</span>, t)</span>
<span id="cb3-135"><a href="#cb3-135" aria-hidden="true" tabindex="-1"></a>        plays <span class="op">=</span> <span class="bu">len</span>(history[rd])</span>
<span id="cb3-136"><a href="#cb3-136" aria-hidden="true" tabindex="-1"></a>        acting_player <span class="op">=</span> plays <span class="op">%</span> <span class="dv">2</span></span>
<span id="cb3-137"><a href="#cb3-137" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print('*************')</span></span>
<span id="cb3-138"><a href="#cb3-138" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print('HISTORY RD', history[rd])</span></span>
<span id="cb3-139"><a href="#cb3-139" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print('PLAYS', plays)</span></span>
<span id="cb3-140"><a href="#cb3-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-141"><a href="#cb3-141" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> plays <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb3-142"><a href="#cb3-142" aria-hidden="true" tabindex="-1"></a>            p0total <span class="op">=</span> np.<span class="bu">sum</span>(history[rd][<span class="dv">0</span>::<span class="dv">2</span>])</span>
<span id="cb3-143"><a href="#cb3-143" aria-hidden="true" tabindex="-1"></a>            p1total <span class="op">=</span> np.<span class="bu">sum</span>(history[rd][<span class="dv">1</span>::<span class="dv">2</span>])</span>
<span id="cb3-144"><a href="#cb3-144" aria-hidden="true" tabindex="-1"></a>            <span class="co"># print('P0 TOTAL', p0total)</span></span>
<span id="cb3-145"><a href="#cb3-145" aria-hidden="true" tabindex="-1"></a>            <span class="co"># print('P1 TOTAL', p1total)</span></span>
<span id="cb3-146"><a href="#cb3-146" aria-hidden="true" tabindex="-1"></a>            <span class="co"># print('ROUND BEG', rd)</span></span>
<span id="cb3-147"><a href="#cb3-147" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb3-148"><a href="#cb3-148" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> p0total <span class="op">==</span> p1total:</span>
<span id="cb3-149"><a href="#cb3-149" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> rd <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> p0total <span class="op">!=</span> <span class="dv">19</span>:</span>
<span id="cb3-150"><a href="#cb3-150" aria-hidden="true" tabindex="-1"></a>                    rd <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-151"><a href="#cb3-151" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># print('ROUND TO 1')</span></span>
<span id="cb3-152"><a href="#cb3-152" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb3-153"><a href="#cb3-153" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># print('SHOWDOWN RETURN')</span></span>
<span id="cb3-154"><a href="#cb3-154" aria-hidden="true" tabindex="-1"></a>                    winner <span class="op">=</span> <span class="va">self</span>.winning_hand(cards)</span>
<span id="cb3-155"><a href="#cb3-155" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> winner <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb3-156"><a href="#cb3-156" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-157"><a href="#cb3-157" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">elif</span> traversing_player <span class="op">==</span> winner:</span>
<span id="cb3-158"><a href="#cb3-158" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">return</span> pot<span class="op">/</span><span class="dv">2</span></span>
<span id="cb3-159"><a href="#cb3-159" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">elif</span> traversing_player <span class="op">!=</span> winner:</span>
<span id="cb3-160"><a href="#cb3-160" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">return</span> <span class="op">-</span>pot<span class="op">/</span><span class="dv">2</span></span>
<span id="cb3-161"><a href="#cb3-161" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-162"><a href="#cb3-162" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> history[rd][<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> <span class="dv">0</span>: <span class="co">#previous player folded</span></span>
<span id="cb3-163"><a href="#cb3-163" aria-hidden="true" tabindex="-1"></a>                <span class="co"># print('FOLD RETURN')</span></span>
<span id="cb3-164"><a href="#cb3-164" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> acting_player <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> acting_player <span class="op">==</span> traversing_player:</span>
<span id="cb3-165"><a href="#cb3-165" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> p1total<span class="op">+</span><span class="dv">1</span></span>
<span id="cb3-166"><a href="#cb3-166" aria-hidden="true" tabindex="-1"></a>                <span class="cf">elif</span> acting_player <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> acting_player <span class="op">!=</span> traversing_player:</span>
<span id="cb3-167"><a href="#cb3-167" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> <span class="op">-</span>(p1total <span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb3-168"><a href="#cb3-168" aria-hidden="true" tabindex="-1"></a>                <span class="cf">elif</span> acting_player <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> acting_player <span class="op">==</span> traversing_player:</span>
<span id="cb3-169"><a href="#cb3-169" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> p0total<span class="op">+</span><span class="dv">1</span></span>
<span id="cb3-170"><a href="#cb3-170" aria-hidden="true" tabindex="-1"></a>                <span class="cf">elif</span> acting_player <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> acting_player <span class="op">!=</span> traversing_player:</span>
<span id="cb3-171"><a href="#cb3-171" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> <span class="op">-</span>(p0total <span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb3-172"><a href="#cb3-172" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print('ROUND AFTER', rd)</span></span>
<span id="cb3-173"><a href="#cb3-173" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> rd <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-174"><a href="#cb3-174" aria-hidden="true" tabindex="-1"></a>            infoset <span class="op">=</span> <span class="bu">str</span>(cards[acting_player]) <span class="op">+</span> <span class="bu">str</span>(history)</span>
<span id="cb3-175"><a href="#cb3-175" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> rd <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-176"><a href="#cb3-176" aria-hidden="true" tabindex="-1"></a>            infoset <span class="op">=</span> <span class="bu">str</span>(cards[acting_player]) <span class="op">+</span> <span class="bu">str</span>(cards[<span class="dv">2</span>]) <span class="op">+</span> <span class="bu">str</span>(history)</span>
<span id="cb3-177"><a href="#cb3-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-178"><a href="#cb3-178" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> acting_player <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-179"><a href="#cb3-179" aria-hidden="true" tabindex="-1"></a>            infoset_bets <span class="op">=</span> <span class="va">self</span>.valid_bets(history, rd, <span class="dv">0</span>)</span>
<span id="cb3-180"><a href="#cb3-180" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> acting_player <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-181"><a href="#cb3-181" aria-hidden="true" tabindex="-1"></a>            infoset_bets <span class="op">=</span> <span class="va">self</span>.valid_bets(history, rd, <span class="dv">1</span>)</span>
<span id="cb3-182"><a href="#cb3-182" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print('ROUND', rd)</span></span>
<span id="cb3-183"><a href="#cb3-183" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print('INFOSET BETS', infoset_bets)</span></span>
<span id="cb3-184"><a href="#cb3-184" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> infoset <span class="kw">not</span> <span class="kw">in</span> <span class="va">self</span>.nodes:</span>
<span id="cb3-185"><a href="#cb3-185" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.nodes[infoset] <span class="op">=</span> Node(infoset_bets)</span>
<span id="cb3-186"><a href="#cb3-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-187"><a href="#cb3-187" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(self.nodes[infoset])</span></span>
<span id="cb3-188"><a href="#cb3-188" aria-hidden="true" tabindex="-1"></a>        <span class="co"># print(infoset)</span></span>
<span id="cb3-189"><a href="#cb3-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-190"><a href="#cb3-190" aria-hidden="true" tabindex="-1"></a>        nodes_touched <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-191"><a href="#cb3-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-192"><a href="#cb3-192" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> acting_player <span class="op">==</span> traversing_player:</span>
<span id="cb3-193"><a href="#cb3-193" aria-hidden="true" tabindex="-1"></a>            util <span class="op">=</span> defaultdict(<span class="bu">int</span>)</span>
<span id="cb3-194"><a href="#cb3-194" aria-hidden="true" tabindex="-1"></a>            node_util <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-195"><a href="#cb3-195" aria-hidden="true" tabindex="-1"></a>            strategy <span class="op">=</span> <span class="va">self</span>.nodes[infoset].get_strategy()</span>
<span id="cb3-196"><a href="#cb3-196" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> a <span class="kw">in</span> infoset_bets:</span>
<span id="cb3-197"><a href="#cb3-197" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> rd <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-198"><a href="#cb3-198" aria-hidden="true" tabindex="-1"></a>                    next_history <span class="op">=</span> [history[<span class="dv">0</span>] <span class="op">+</span> [a], history[<span class="dv">1</span>]]</span>
<span id="cb3-199"><a href="#cb3-199" aria-hidden="true" tabindex="-1"></a>                <span class="cf">elif</span> rd <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-200"><a href="#cb3-200" aria-hidden="true" tabindex="-1"></a>                    next_history <span class="op">=</span> [history[<span class="dv">0</span>], history[<span class="dv">1</span>] <span class="op">+</span> [a]]</span>
<span id="cb3-201"><a href="#cb3-201" aria-hidden="true" tabindex="-1"></a>                pot <span class="op">+=</span> a</span>
<span id="cb3-202"><a href="#cb3-202" aria-hidden="true" tabindex="-1"></a>                util[a] <span class="op">=</span> <span class="va">self</span>.external_cfr(cards, next_history, rd, pot, nodes_touched, traversing_player, t)</span>
<span id="cb3-203"><a href="#cb3-203" aria-hidden="true" tabindex="-1"></a>                node_util <span class="op">+=</span> strategy[a] <span class="op">*</span> util[a]</span>
<span id="cb3-204"><a href="#cb3-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-205"><a href="#cb3-205" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> a <span class="kw">in</span> infoset_bets:</span>
<span id="cb3-206"><a href="#cb3-206" aria-hidden="true" tabindex="-1"></a>                regret <span class="op">=</span> util[a] <span class="op">-</span> node_util</span>
<span id="cb3-207"><a href="#cb3-207" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.nodes[infoset].regret_sum[a] <span class="op">+=</span> regret</span>
<span id="cb3-208"><a href="#cb3-208" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> node_util</span>
<span id="cb3-209"><a href="#cb3-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-210"><a href="#cb3-210" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: <span class="co">#acting_player != traversing_player</span></span>
<span id="cb3-211"><a href="#cb3-211" aria-hidden="true" tabindex="-1"></a>            strategy <span class="op">=</span> <span class="va">self</span>.nodes[infoset].get_strategy()</span>
<span id="cb3-212"><a href="#cb3-212" aria-hidden="true" tabindex="-1"></a>            <span class="co"># print('STRATEGY', strategy)</span></span>
<span id="cb3-213"><a href="#cb3-213" aria-hidden="true" tabindex="-1"></a>            dart <span class="op">=</span> random.random()</span>
<span id="cb3-214"><a href="#cb3-214" aria-hidden="true" tabindex="-1"></a>            <span class="co"># print('DART', dart)</span></span>
<span id="cb3-215"><a href="#cb3-215" aria-hidden="true" tabindex="-1"></a>            strat_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-216"><a href="#cb3-216" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> a <span class="kw">in</span> strategy:</span>
<span id="cb3-217"><a href="#cb3-217" aria-hidden="true" tabindex="-1"></a>                strat_sum <span class="op">+=</span> strategy[a]</span>
<span id="cb3-218"><a href="#cb3-218" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> dart <span class="op">&lt;</span> strat_sum:</span>
<span id="cb3-219"><a href="#cb3-219" aria-hidden="true" tabindex="-1"></a>                    action <span class="op">=</span> a</span>
<span id="cb3-220"><a href="#cb3-220" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb3-221"><a href="#cb3-221" aria-hidden="true" tabindex="-1"></a>            <span class="co"># print('ACTION', action)</span></span>
<span id="cb3-222"><a href="#cb3-222" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> rd <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-223"><a href="#cb3-223" aria-hidden="true" tabindex="-1"></a>                next_history <span class="op">=</span> [history[<span class="dv">0</span>] <span class="op">+</span> [action], history[<span class="dv">1</span>]]</span>
<span id="cb3-224"><a href="#cb3-224" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> rd <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-225"><a href="#cb3-225" aria-hidden="true" tabindex="-1"></a>                next_history <span class="op">=</span> [history[<span class="dv">0</span>], history[<span class="dv">1</span>] <span class="op">+</span> [action]]</span>
<span id="cb3-226"><a href="#cb3-226" aria-hidden="true" tabindex="-1"></a>            pot <span class="op">+=</span> action</span>
<span id="cb3-227"><a href="#cb3-227" aria-hidden="true" tabindex="-1"></a>            <span class="co"># if acting_player == 0:</span></span>
<span id="cb3-228"><a href="#cb3-228" aria-hidden="true" tabindex="-1"></a>            <span class="co">#   p0stack -= action</span></span>
<span id="cb3-229"><a href="#cb3-229" aria-hidden="true" tabindex="-1"></a>            <span class="co"># elif acting_player == 1:</span></span>
<span id="cb3-230"><a href="#cb3-230" aria-hidden="true" tabindex="-1"></a>            <span class="co">#   p1stack -= action</span></span>
<span id="cb3-231"><a href="#cb3-231" aria-hidden="true" tabindex="-1"></a>            <span class="co"># print('NEXT HISTORY2', next_history)</span></span>
<span id="cb3-232"><a href="#cb3-232" aria-hidden="true" tabindex="-1"></a>            util <span class="op">=</span> <span class="va">self</span>.external_cfr(cards, next_history, rd, pot, nodes_touched, traversing_player, t)</span>
<span id="cb3-233"><a href="#cb3-233" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> a <span class="kw">in</span> infoset_bets:</span>
<span id="cb3-234"><a href="#cb3-234" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.nodes[infoset].strategy_sum[a] <span class="op">+=</span> strategy[a]</span>
<span id="cb3-235"><a href="#cb3-235" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> util</span>
<span id="cb3-236"><a href="#cb3-236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-237"><a href="#cb3-237" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb3-238"><a href="#cb3-238" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> LeducCFR(<span class="dv">1000</span>, <span class="dv">3</span>, <span class="dv">20</span>)</span>
<span id="cb3-239"><a href="#cb3-239" aria-hidden="true" tabindex="-1"></a>    k.cfr_iterations_external()</span>
<span id="cb3-240"><a href="#cb3-240" aria-hidden="true" tabindex="-1"></a>    <span class="co"># for i in range(20):</span></span>
<span id="cb3-241"><a href="#cb3-241" aria-hidden="true" tabindex="-1"></a>    <span class="co">#   print(k.valid_bets([[i],[]], 0, 19))</span></span>
<span id="cb3-242"><a href="#cb3-242" aria-hidden="true" tabindex="-1"></a>    <span class="co">#a = k.valid_bets([[4, 18],[]], 0, 15)</span></span>
<span id="cb3-243"><a href="#cb3-243" aria-hidden="true" tabindex="-1"></a>    <span class="co">#print(a)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The External Sampling Leduc Poker CFR code works similarly to the Kuhn Poker, but has some additional complications resulting from Leduc Poker having a second betting round and in general having a slightly more complex hand structure whereby there are six cards in the deck and the first round is each player getting dealt a single card followed by a limit hold’em betting round capped at four bets, then potentially a second flop round where another community card is revealed and hand strengths can improve if the card is paired with the card on the board.</p>
</section>
<section id="chance-sampling" class="level4">
<h4 class="anchored" data-anchor-id="chance-sampling">Chance Sampling</h4>
<p>The Chance Sampling CFR variation selects a single chance node at the root of the tree. In poker, this is equivalent to selecting a specific dealing of the cards to both players. For example, in Kuhn poker where there are 3 cards and each player is dealt one of them, there are 6 combinations of possible dealings (KQ, KJ, QJ, QK, JK, JQ), each with equal probability. After this selection, CFR is run for all branches of the tree after this chance node. This is equivalent to using the non-sampled counterfactual values and ignoring chance in the counterfactual.</p>
<p>Here are the steps for Chance Sampling: 1. Check to see if at a terminal node. If so, return the profit from the acting player’s perspective. 2. If not terminal, create or access an information set that is the card of the node’s acting player + the history up to this point. For example: qb. - Information set node call is set up with vectors for regret_sum, strategy, and strategy_sum 3. Get strategy vector of the acting player based on the normalized regret_sum at the node. We also pass int he reach probability of that player getting to this node so we can keep the strategy_sum vector (reach_prob * strategy[action]) 4. Iterate over the actions, update history, and make a recursive CFR call: - util[a] = -cfr(cards, next_history, p0 * strategy[a], p1) &lt;– Example for player 0 - Negative because the next node value will be in terms of the other player 5. Node utility is weighted sum of each strategy[a] * util[a] 6. Again iterate over each action to update regrets - Regret = util[a] - node_util - Update the regret_sum at the infoset node for the acting player to be the regret * the reach probability of the opponent (the counterfactual part of the regrets) 7. Return node_util</p>
<p>Now we relate the steps to the algorithm below:</p>
<p>Below we show a figure of the MCCFR algorithm for Chance Sampling. The algorithm works by calling CFR for each player over T iterations (lines 32-37) given a single vector of cards of both players, history of plays, and each player’s reach probabilities. If the history h is terminal, then a utility value can be returned (lines 6-7). If this is the beginning of the game tree and a chance node, then a single outcome is sampled and CFR is recursively called again (lines 8- 10). If the node is neither a chance node or a terminal node, then for each action, CFR is recursively called with the new history and an updated reach probability (lines 15- 20). The weighted utilities of the actions is summed to find the node utility (line 21). On the iteration of the i player, regret and strategy sum values are stored for each action by adding the counterfactual regret (line 25) and the weighted strategy (line 26) to the previous values. The strategy values will be averaged at the end to find the Nash equilibrium strategy and the regret values are used with regret matching to find the next strategy (line 26).</p>
<p>The non-sampling Vanilla CFR would simply iterate over every chance outcome (every possible deal of the private cards) instead of sampling a single outcome on line 9.</p>
<p>Vanilla CFR has i iterations going through entire tree and Chance CFR has i iterations starting with a particular random deal of private cards. Each iteration updates nodes for both players. CFR returns utility of game state (initially called at root) from player 1’s perspective. The average of these over all the iterations from the root is the “game value”.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../assets/section4/cfr/chancesampling.png" title="Chance Sampling Algorithm" class="img-fluid figure-img"></p>
<figcaption>Chance Sampling Algorithm</figcaption>
</figure>
</div>
<p>Code of the Vanilla version written in Java is available <a href="https://www.dropbox.com/sh/82yxtuceybmf5tm/AADVmM2oWmbaebpk7X9Iyxtba?">here</a>.</p>
<p>Code including a best response function for the Chance Sampling algorithm is available <a href="https://www.dropbox.com/sh/82yxtuceybmf5tm/AADVmM2oWmbaebpk7X9Iyxtba?">here</a> in Java.</p>
</section>
</section>
</section>
<section id="going-through-an-iteration" class="level2">
<h2 class="anchored" data-anchor-id="going-through-an-iteration">Going through an Iteration</h2>
<p>Here we show two full iterations of Chance Sampled CFR where we assume that the chance node has selected P1 Queen and P2 King as the random draw and then iterates over the entire tree from there.</p>
<p>First we show the initialization of the algorithm which has four information sets (the card + the history of actions). At each information set the regret sum is stored where the first number represents the accumulated regret for passing and the second number represents the accumulated regret for betting. The strategy column is the behavioral strategy at that information set node, based on using regret matching with the accumulated regrets. Finally, the strategy sum is what we average at the end to find the Nash equilibrium strategy.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../assets/section4/cfr/init.png" title="Algorithm initialization" class="img-fluid figure-img"></p>
<figcaption>Algorithm initialization</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../assets/section4/cfr/iter1.png" title="Iteration 1" class="img-fluid figure-img"></p>
<figcaption>Iteration 1</figcaption>
</figure>
</div>
<p>Here is the sequence of what the algorithm does in the first iteration:</p>
<p>Player 1 plays p = 0.5 at node Q.</p>
<p>Player 2 plays p = 0.5 at node Kp and gets utility of 1 for action p at node Kp.</p>
<p>Player 2 plays b = 0.5 at node Kp.</p>
<p>Player 1 plays p = 0.5 at node Qpb and gets utility of -1. Player 1 plays b = 0.5 at node Qpb and gets utility of -2. Node Qpb has overall utility of 0.5 * -1 + 0.5 * -2 = -1.5. Regret for playing p is -1 - (-1.5) = 0.5. Regret for playing b is -2 - (-1.5) = -0.5.</p>
<p>Regret_sum updates are regret * p(opponent playing to node) so here we have regret_sum[p] += 0.5 * 0.5 = 0.25 and regret_sum[b] += -0.5 * 0.5 = -0.25.</p>
<p>Node Qpb is valued at 1.5 for player 2 (opposite of what it was for player 1). Now from node Kp, player 2 had value 1 if playing p and value 1.5 if playing b, for a node_utility of 1.25. The regret for playing p is 1-1.25 = -0.25 and regret for playing b is 1.5-1.25 = 0.25.</p>
<p>Regret_sum updates are regret_sum[p] += -0.25 * 0.5 = -0.125 and regret_sum[b] += 0.25 * 0.5 = 0.125.</p>
<p>Node Kp is now valued at -1.25 for player 1 action p.&nbsp;Player 1 now takes action b = 0.5 from node Q. Then player 2 takes action p = 0.5 from node Kb and gets utility -1. Then player 2 takes action b = 0.5 from node Kb and gets utility 2. The node_util is 0.5. Regret for playing p is -1 - 0.5 = -1.5. Regret for playing b is 2 - 0.5 = 1.5.</p>
<p>Regret_sum updates are regret_sum[p] += -1.5 * 0.5= -0.75 and regret_sum[b] += 1.5 * 0.5 = 0.75.</p>
<p>Node Kb is now valued at -0.5 for player 1 action b. The node_util for node Q is 0.5 * -1.25 for action p and -0.5 * 0.5 for action b = -0.875. Regret for playing p is -1.25 - (-0.875) = -0.375 and regret for playing b is -0.5 - (-0.875) = 0.375. Regret_sum updates are regret_sum[p] += -0.375</p>
<p>Strategy_sum updates are probabilities of the node player not including the opponent playing to that action. So after this iteration each node was updated to [0.5, 0.5] except for the bottom node Qpb, which is [0.25, 0.25] since reaching that node comes after playing p = 0.5 in node Q, so both are 0.5 * 0.5.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../assets/section4/cfr/iter2begin.png" title="Algorithm before iteration 2" class="img-fluid figure-img"></p>
<figcaption>Algorithm before iteration 2</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../assets/section4/cfr/iter2.png" title="Iteration 2" class="img-fluid figure-img"></p>
<figcaption>Iteration 2</figcaption>
</figure>
</div>
<p>Player 1 plays p = 0 at node Q.</p>
<p>Player 2 plays p = 0 at node Kp and gets utility of 1.</p>
<p>Player 2 plays b = 0.5 at node Kp.</p>
<p>Player 1 plays p = 0.5 at node Qpb and gets utility of -1. Player 1 plays b = 0.5 at node Qpb and gets utility of -2. Node Qpb has overall utility of 0.5 * -1 + 0.5 * -2 = -1.5. Regret for playing p is -1 - (-1.5) = 0.5. Regret for playing b is -2 - (-1.5) = -0.5.</p>
<p>Regret_sum updates are regret * p(opponent playing to node) so here we have regret_sum[p] += 0.5 * 0.5 = 0.25 and regret_sum[b] += -0.5 * 0.5 = -0.25.</p>
<p>Node Qpb is valued at 1.5 for player 2 (opposite of what it was for player 1). Now from node Kp, player 2 had value 1 if playing p and value 1.5 if playing b, for a node_utility of 1.25. The regret for playing p is 1-1.25 = -0.25 and regret for playing b is 1.5-1.25 = 0.25.</p>
<p>Regret_sum updates are regret_sum[p] += -0.25 * 0.5 = -0.125 and regret_sum[b] += 0.25 * 0.5 = 0.125.</p>
<p>Node Kp is now valued at -1.25 for player 1 action p.&nbsp;Player 1 now takes action b = 0.5 from node Q. Then player 2 takes action p = 0.5 from node Kb and gets utility -1. Then player 2 takes action b = 0.5 from node Kb and gets utility 2. The node_util is 0.5. Regret for playing p is -1 - 0.5 = -1.5. Regret for playing b is 2 - 0.5 = 1.5.</p>
<p>Regret_sum updates are regret_sum[p] += -1.5 * 0.5= -0.75 and regret_sum[b] += 1.5 * 0.5 = 0.75.</p>
<p>Node Kb is now valued at -0.5 for player 1 action b. The node_util for node Q is 0.5 * -1.25 for action p and -0.5 * 0.5 for action b = -0.875. Regret for playing p is -1.25 - (-0.875) = -0.375 and regret for playing b is -0.5 - (-0.875) = 0.375. Regret_sum updates are regret_sum[p] += -0.375</p>
<p>Strategy_sum updates are probabilities of the node player not including the opponent playing to that action. So after this iteration each node was updated to [0.5, 0.5] except for the bottom node Qpb, which is [0.25, 0.25] since reaching that node comes after playing p = 0.5 in node Q, so both are 0.5 * 0.5.</p>
<section id="comparing-algorithms" class="level3">
<h3 class="anchored" data-anchor-id="comparing-algorithms">Comparing Algorithms</h3>
<p>We compared four CFR algorithms (Chance Sampling, External Sampling, Vanilla, and CFR+) in terms of exploitability vs.&nbsp;nodes touched (a measure of how long the algorithm has been running for) and then also look at two of those algorithms which are very similar, CFR and its recent update, CFR+, in terms of exploitability vs.&nbsp;time. Finally, we produce strategy charts that show a Nash equilibrium strategy for each player at all four stages of the game. CFR+ is explained more in the CFR Advances section, but in short resets regrets that have gone negative to 0 so they are more likely to have a chance to “rebound” in case they were actually good strategies that, for example, just got unlucky.</p>
<p>The simulations run for a set number of iterations and the regrets for all algorithms are updated after each iteration.</p>
<p>As the algorithms run, a best response function is called periodically, which iterates once through the game tree once for each player. The average of the best response values from each player is taken as the exploitability of the game at that point. All graphs show exploitability on the vertical axis on a log scale. CFR and CFR+ were run for 100,000 iterations and Chance and External Sampling were run for 10^9 iterations. Since the non-sampling algorithms require entire tree traversals for each iteration, they require far fewer iterations to reach the same number of nodes. The game value for all variants is -0.0566, as we have found in previous sections.</p>
<p>We examine nodes touched vs.&nbsp;exploitability for all four of our CFR algorithm types (Vanilla CFR vs.&nbsp;CFR+ vs.&nbsp;Chance Sampling vs.&nbsp;External Sampling) up to 4 * 10^9 nodes touched for each. Monte Carlo sampling methods require many more iterations than Vanilla CFR, while each iteration is relatively fast. Therefore, a nodes touched metric makes sense as a way of comparison.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../assets/section4/cfr/compare4.png" title="CFR Algs Compared" class="img-fluid figure-img"></p>
<figcaption>CFR Algs Compared</figcaption>
</figure>
</div>
<p>We can see that the sampled versions show a lower exploitability much faster than the Vanilla and CFR+ versions, although they are more erratic due to the sampling. While Chance Sampling is generally superior to External Sampling, they are quite close at the end of the experiment. Chance Sampling is the simplest algorithm, which may work in its favor since Kuhn Poker is also a very simple game. Vanilla CFR shows consistently lower exploitability than CFR+. Perhaps this is because CFR+ doesn’t allow regrets to become negative, it may then waste time on actions that would have gone negative.</p>
<p>We also experimented with time vs.&nbsp;exploitability. The algorithms and code for CFR+ and CFR are exactly the same except for how the regret is calculated and since this eliminates other sources of variability, we are able to reasonably compare CFR and CFR+ exploitability against time.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../assets/section4/cfr/timecompare.png" title="CFR CFR+ Time vs. Exploitability" class="img-fluid figure-img"></p>
<figcaption>CFR CFR+ Time vs.&nbsp;Exploitability</figcaption>
</figure>
</div>
<p>This graph shows that CFR+ takes significantly more time to complete its 100,000 iterations and yet is still at a higher exploitability. Since the only difference in the algorithms is that CFR+ does not allow regrets to become negative, this must be the cause of the additional calculation time needed.</p>
</section>
</section>
<section id="similarities-to-reinforcement-learning" class="level2">
<h2 class="anchored" data-anchor-id="similarities-to-reinforcement-learning">Similarities to Reinforcement Learning</h2>
<p>In reinforcement learning, agents learn what actions to take in an environment based on the rewards they’ve seen in the past. This is very similar to how regret updates work in CFR – we can think of the regrets as advantage functions, which is the value of a certain action compared to the value of a state, and in fact this terminology has been seen in recent papers like the Deep CFR paper. We can also compare this to having independent multiarm bandits at each decision point, learning from all of them simultaneously.</p>



</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>© 2024 pokercamp.org. All rights reserved.</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>