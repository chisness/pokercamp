---
title: "RPS Hackathon @ Fractal: Guide to Building a Bot"
sidebar: rps-hackathon-fractal
bread-crumbs: false
format:
  html:
    math: true
---
## Starter Code
We provide Python starter code so that you can mainly think about problem solving and worry less about the code details. 

We provide code that can play the following basic strategies. By default the Random strategy is playing, which [guarantees a breakeven result](#game-theory-equilibrium). You can comment out one strategy and uncomment another to use a different one. 

1. **Random:** You are guaranteed to breakeven in expectation if you play randomly
2. **Win vs. Last Action:** Play the action that beats the opponent's last move
3. **Win vs. History:** Play the action that beats the opponent's most frequent move over the entire history

### Variables

The profit so far in the match is stored in: 

- `self.my_profit`

And the history of your actions and your opponent actions are stored in the following array, where each history is a tuple of `(my_action, their_action)`.  

- `self.history[]`

### Functions

- `def __init__(self)`: 
  - Initializes profit `self.my_profit`
  - Initializes the history array `self.history[]`
- `handle_results(self, *, my_action, their_action, my_payoff, match_clock)`: 
  - This is run at the end of every game
  - It updates the history with `my_action` and `their_action` 
  - It updates the payoff with `my_payoff`
  - `match_clock` can be used to see how much of your 30 second total time is remaining (this can generally be ignored) 
- `def get_action(self, *, match_clock)`: 
  - This is the main function where you run your strategy and return an action
  - You can return `RockAction()`, `PaperAction()`, or `ScissorsAction()`. 

## Writing Your Own Bot
Since there are many suboptimal environment bots, breaking even by playing randomly won't be a good enough overall strategy, but could be valuable to consider in some situations. Below we show a couple of strategies that involve updating the starter code and using random play in combination with another strategy. 

### Starter Code Modification
One of the pieces of starter code that we provide is "Win vs. Last Action". Suppose that you have a theory that you should actually play to beat the action that they played *two* games ago. 

You could try something like this: 

- If you're winning or tying, then play to beat the action from 2 games ago 80% of the time and play randomly 20% of the time so that you aren't too predictable
- If you're losing (i.e. maybe this strategy is not working well), then always play randomly

```python
# If losing, play randomly
if self.my_profit < 0:
    return random.choice([RockAction(), PaperAction(), ScissorsAction()])

# If winning or tying, and there is at least 2 rounds of history
if len(self.history) >= 2:
    # 80% chance to play based on opponent's action from 2 rounds ago
    if random.random() < 0.8:
        two_rounds_ago = self.history[-2][1]  # Opponent's action from 2 rounds ago
        if isinstance(two_rounds_ago, RockAction):
            return PaperAction()
        elif isinstance(two_rounds_ago, PaperAction):
            return ScissorsAction()
        else:  # ScissorsAction
            return RockAction()

# In all other cases (including first 2 rounds), play randomly
return random.choice([RockAction(), PaperAction(), ScissorsAction()])
```

### Exploiting a Weak Bot
In practice in this hackathon, a lot of value will come from exploiting weak bots or other opponents. 

For example, you could check to see if any bot is always playing Rock. If so, you always play Paper. If not, you play randomly. Then you will breakeven against everyone, but crush the Rock-only bot. 

Here's how to execute this strategy: 

```python
# Check if the opponent has played at least once
if self.history:
    # Get all of the opponent's moves
    opponent_moves = [move[1] for move in self.history]
    
    # Count how many times the opponent played Rock
    rock_count = sum(1 for move in opponent_moves if isinstance(move, RockAction))
    
    # If opponent has only played Rock, we play Paper
    if rock_count == len(opponent_moves):
        return PaperAction()

# If it's the first move or opponent hasn't only played Rock, play randomly
return random.choice([RockAction(), PaperAction(), ScissorsAction()])
```

### Exploiting a Weak Bart
<iframe width="560" height="315" src="https://www.youtube.com/embed/b0SoKWLkmLU?si=0AQ3_NgHOe4tc4OU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

(Bad joke)

## Problem Solving and Strategy

The goal of the hackathon is to figure out how to adapt to your opponents (other participants and environment bots)! 

A few possible strategies are: 

- Single out specific bots that are exploitable and write code to identify and exploit them
  - Build an ensemble of exploits targeting many opponents
- Attempt to predict the next move of each bot using a general algorithm
- Use random play as a backup plan (see below for a full explanation of why this Nash equilibrium strategy always breaks even)

## LLMs
We welcome and suggest that you use LLMs like [Claude](https://claude.ai) or [ChatGPT](https://chatgpt.com). You can provide the starter code and get their help with implementing better strategies. 

## Game Theory Equilibrium

RPS is a zero-sum game and the payouts are symmetrical as follows: 

| Player 1/2 | Rock    | Paper   | Scissors |
|--------|---------|---------|----------|
| Rock   | (0, 0)  | (-1, 1) | (1, -1)  |
| Paper  | (1, -1) | (0, 0)  | (-1, 1)  |
|Scissors| (-1, 1) | (1, -1) | (0, 0)   |

The Nash Equilibrium strategy is to play each action $r = p = s = 1/3$ of the time. 

:::{.callout-tip collapse="true" appearance="minimal"}
## Nash Equilibrium Strategy for RPS
If Player 1 plays Rock with probability $r$, Paper with probability $p$, and Scissors with probability $s$, we have the following expected value equations for Player 2: 

$\mathbb{E}(\text{R}) = -1p + 1s$

$\mathbb{E}(\text{P}) = 1r - 1s$

$\mathbb{E}(\text{S}) = -1r + 1p$

Since no action dominates, we know that the EV of every strategic action should be equal  (since if a certain strategy was best, we'd want to always play that strategy). 

To solve for $r$, $p$, and $s$, we can start by setting these EVs equal: 

$\mathbb{E}(\text{R}) = \mathbb{E}(\text{P})$

$-1p + 1s = 1r - 1s$

$2s = p + r$

Then setting these equal: 

$\mathbb{E}(\text{R}) = \mathbb{E}(\text{S})$

$-1p + 1s = -1r + 1p$

$s + r = 2p$

And finally setting these equal: 

$\mathbb{E}(\text{P}) = \mathbb{E}(\text{S})$

$1r - 1s = -1r + 1p$

$2r = s + p$

Now we have these equations:  

$$
\begin{cases}
2s = p + r \\
s + r = 2p \\
2r = s + p
\end{cases}
$$

We can rewrite the 1st: 

$r = 2s - p$

And combine with the 2nd: 

$s + (2s - p) = 2p$

$3s = 3p$

Resulting in: 

$s = p$

Now we can go back to the 2nd equation: 

$s + r = 2p$

And insert $s$ = $p$: 

$s + r = 2s$

And arrive at: 

$r = s$

We now see that all are equal: 

$s = p = r$

We also know that they must all sum to $1$: 

$r + p + s = 1$

Since they're all equal and sum to $1$, we can substitute $p$ and $s$ with $r$: 

$3r = 1$

$r = 1/3$

So all actions are taken with probability $1/3$: 

$r = p = s = 1/3 \quad \blacksquare$
:::

Playing this strategy means that whatever your opponent does, you will breakeven! For example, think about an opponent that always plays Rock. 

$$
\begin{equation}
\begin{split}
\mathbb{E}(\text{Equilibrium vs. Rock}) &= r*0 + p*1 + s*-1 \\
&= 1/3*0 + 1/3*1 + 1/3*-1 \\
&= 0
\end{split}
\end{equation}
$$

## Submitting Bots
To get started, click the [Login](https://poker.camp/login/) button to the left and then go to [Submit Your Bot](https://poker.camp/rps-hackathon-fractal/botsubmit.html). On the bot submission page, it's possible to submit with: 

- Code text boxes directly on the webpage
- File upload a single `player.py` Python file 

### Submission Results
Upon submission, you will be shown a matrix of results against every other bot. You'll also be able to see the first 100 and last 100 games against each bot. 

### During Round Submissions
Starting in the 2nd round, any submission during the round will show you a test result against all bots from the *previous* round.

### End of Round Submissions
Your last submission during each round will be the one that is entered into that round's competition.

