---
title: "RPS Hackathon @ Fractal: Guide to Building a Bot"
sidebar: rps-hackathon-fractal
bread-crumbs: false
format:
  html:
    math: true
---
## Starter Code
We provide Python starter code so that you can mainly think about the problem solving and worry less about the code details. 

We provide bots that can play the following basic strategies: 

1. **Random:** You are guaranteed to breakeven in expectation if you play randomly
2. **Percentage:** You can choose a fixed percentage (e.g. 50% rock, 25% paper, 25% scissors)
3. **Win vs. Last Action:** Play the action that beats the opponent's last move
4. **Win vs. History:** Play the action that beats the opponent's most frequent move over the entire history

The histories of the entire match are stored in these arrays: 

- `self.my_history[]` 
- `self.opponent_history[]`
- `self.results_history[]`

The functions in the code are: 

- `def __init__(self)`: Initializes the history arrays
- `handle_new_round(self, game_state, round_state, active)`: This is run for every new game
- `def handle_round_over(self, game_state, terminal_state, active)`: This is run at the end of every game
- `def get_action(self, game_state, round_state, active)`: This is the main function where you run your strategy

```python
# active (same at newround, getaction, and roundover): Returns 0 or 1
# You are assigned 0 or 1 for each round 

# round_state (same at newround and getaction): RoundState(turn_number=0, street=0, pips=[1, 1], stacks=[0, 0], hands=[3, None], deck=None, action_history=[], previous_state=None)
# terminal_state: TerminalState(deltas=[1, -1], previous_state=RoundState(turn_number=0, street=0, pips=[1, 1], stacks=[0, 0], hands=[3, None], deck=None, action_history=[Paper, Rock], previous_state=RoundState(turn_number=0, street=0, pips=[1, 1], stacks=[0, 0], hands=[3, None], deck=None, action_history=[Paper], previous_state=RoundState(turn_number=0, street=0, pips=[1, 1], stacks=[0, 0], hands=[3, None], deck=None, action_history=[], previous_state=None))))
# game_state (same at newround, getaction): GameState(bankroll=10, game_clock=29.988, round_num=1)
# game_state (at end): GameState(bankroll=11, game_clock=29.988, round_num=1)
```


## Writing Your Own Bot

### Starter Code Modification
We give starter code for beating the last opponent action. Suppose that you have a theory that actually the play that opponents tend to repeat the action that they played *two* games ago. 

Let's try this: 

- If we're winning or tying, then we beat the action from 2 games ago 80% of the time and play randomly 20% of the time
- If we're losing, then we always play randomly 


### Exploiting a Weak Bot
Here's an idea for a strategy. You check to see if anyone is always playing Rock. If so, you always play Paper. If not, you play randomly. Then you will breakeven against everyone, but crush the Rock-only bot. 

We can define an `all_rocks` variable that is `True` if the opponent so far has only played Rock and `False` otherwise like this: 

```python
all_rocks = True 
for item in self.opponent_history:
  if item != "RockAction()":
      all_rocks = False
```

Then we can execute our strategy: 

```python
if all_rocks = True:
  return PaperAction()
else:
  return random.choice(RockAction, PaperAction, ScissorsAction)()
```

### Exploiting a Weak Bart
<iframe width="560" height="315" src="https://www.youtube.com/embed/b0SoKWLkmLU?si=0AQ3_NgHOe4tc4OU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

(Yes, bad joke)

## Problem Solving and Strategy

The goal of the hackathon is to figure out how to adapt to your opponents (other participants and environment bots)! 

A few possible strategies are: 

- Single out specific bots that are exploitable and write code to identify and exploit them
- Attempt to predict the next move of each bot using a general algorithm
- Use random play as a backup plan (see below for a full explanation of why this always breaks even and is the Nash equilibrium strategy)

## Game Theory Equilibrium

RPS is a zero-sum game and the payouts are symmetrical as follows: 

| Player 1/2 | Rock    | Paper   | Scissors |
|--------|---------|---------|----------|
| Rock   | (0, 0)  | (-1, 1) | (1, -1)  |
| Paper  | (1, -1) | (0, 0)  | (-1, 1)  |
|Scissors| (-1, 1) | (1, -1) | (0, 0)   |

The Nash Equilibrium strategy is to play each action $r = p = s = 1/3$ of the time. 

:::{.callout-tip collapse="true" appearance="minimal"}
## Nash Equilibrium Strategy for RPS
If Player 1 plays Rock with probability $r$, Paper with probability $p$, and Scissors with probability $s$, we have the following expected value equations for Player 2: 

$\mathbb{E}(\text{R}) = -1p + 1s$

$\mathbb{E}(\text{P}) = 1r - 1s$

$\mathbb{E}(\text{S}) = -1r + 1p$

Since no action dominates, we know that the EV of every strategic action should be equal  (since if a certain strategy was best, we'd want to always play that strategy). 

To solve for $r$, $p$, and $s$, we can start by setting these EVs equal: 

$\mathbb{E}(\text{R}) = \mathbb{E}(\text{P})$

$-1p + 1s = 1r - 1s$

$2s = p + r$

Then setting these equal: 

$\mathbb{E}(\text{R}) = \mathbb{E}(\text{S})$

$-1p + 1s = -1r + 1p$

$s + r = 2p$

And finally setting these equal: 

$\mathbb{E}(\text{P}) = \mathbb{E}(\text{S})$

$1r - 1s = -1r + 1p$

$2r = s + p$

Now we have these equations:  

$$
\begin{cases}
2s = p + r \\
s + r = 2p \\
2r = s + p
\end{cases}
$$

We can rewrite the 1st: 

$r = 2s - p$

And combine with the 2nd: 

$s + (2s - p) = 2p$

$3s = 3p$

Resulting in: 

$s = p$

Now we can go back to the 2nd equation: 

$s + r = 2p$

And insert $s$ = $p$: 

$s + r = 2s$

And arrive at: 

$r = s$

We now see that all are equal: 

$s = p = r$

We also know that they must all sum to $1$: 

$r + p + s = 1$

Since they're all equal and sum to $1$, we can substitute $p$ and $s$ with $r$: 

$3r = 1$

$r = 1/3$

So all actions are taken with probability $1/3$: 

$r = p = s = 1/3 \quad \blacksquare$
:::

Playing this strategy means that whatever your opponent does, you will breakeven! For example, think about an opponent that always plays Rock. 

$$
\begin{equation}
\begin{split}
\mathbb{E}(\text{Equilibrium vs. Rock}) &= r*0 + p*1 + s*-1 \\
&= 1/3*0 + 1/3*1 + 1/3*-1 \\
&= 0
\end{split}
\end{equation}
$$
